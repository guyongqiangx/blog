# 20230816-Android Update Engine 分析（二十）为什么差分包比全量包小，但升级时间却更长？

> 本文为洛奇看世界(guyongqiangx)原创，转载请注明出处。
>
> 原文链接：

## 0. 导读

时不时有同学在 OTA 讨论群和 VIP 答疑群问升级速度的问题，其中一个典型的问题是：

**为什么差分包比全量包小，但升级时间却更长？**



与几百 M 甚至几个 G 的全量包相比，差分包相对较小，有时候甚至小到只有几个 M，这么小的差分包，意味携带的 payload 数据很少，写入很少的数据耗时应该很少才是。但为什么现实中差分升级时，差分包很小，但升级时间却比大很多的全量包升级更长。



我原来也没有系统思考过这个问题。前段时间又有类似话题出现在 VIP 答疑群，几经讨论，这个问题算是彻底弄清楚了。



> 本文演示使用 Android 代码版本：android-13.0.0_r41
>



## 1. 结论

直入主题，先上结论。

差分包比全量包小，只能说明差分包的 payload 数据小。升级文件 payload.bin 主要由两部分组成，前面部分的 manifest 数据以及随后的 payload 数据。

manifest 数据存放了升级中的各种元数据信息，其中包括升级中需要的各种操作 operation，这些 operation 如果有携带数据，则所携带的数据存放在后面的 payload 中。如果 operation 没有携带数据，例如 SOURCE_COPY 负责从升级的源分区(source)向目标(dest)分区复制数据，在随后的



这里把 《Android Update Engine 分析（十八）差分数据到底是如何更新的？》中提到的系统差分升级的 3 个阶段再复习一下：

从宏观上说，整个差分升级过程大致分成三步：

假设升级前的旧系统为 V1, 升级后的新系统为 V2, 差分数据为 Delta

1. 制作差分包

   利用新旧的镜像文件生成差分数据，并打包到 payload.bin 文件中，得到差分包升级文件；

   即：V2(新) - V1(旧) = Delta(差分)

   

2. 传输差分包

   服务端将差分包数据传输给设备端。可以是网络传输，也可以是通过 U 盘复制；

   即：Server(Delta) -> Device(Delta)

   

3. 还原差分包

   设备端接收到差分包升级文件后，基于旧分区，使用差分数据还原，得到新分区数据；

   即：V1(旧) + Delta(差分) = V2(新)



通过上面的这 3 个步骤，利用系统上已有的旧系统 V1 的镜像，通过差分数据 Delta，而不需要传输新系统 V2 的全部镜像文件即可完成升级。
