# Linux 快照 (snapshot) 原理与实践(一)



## 1. 如何理解快照(snapshot)?

snapshot 中文翻译就是快照，但快照究竟是什么? 我在网上看到一个解释，觉得特别准确：

快照(snapshot)，来自照相领域的概念，是指特定时间点的一个状态。

> 来源: [《Git快照(snapshot)到底该如何理解？》, https://www.h5w3.com/82381.html](https://www.h5w3.com/82381.html)

所以，

- 当我们拍照时，照片就表示了被拍摄物体在特定时间点的一个状态；

- 当我们使用 git 对版本进行管理时，每个节点(commit, branch, tag)对应一个快照，记录 git 仓库在该节点的状态；

- 当我们对文件系统创建快照时，快照记录了文件系统在该时间点的状态；



快照有什么用呢？

按照[《Git快照(snapshot)到底该如何理解？》](https://www.h5w3.com/82381.html)一文引用的场景:

> 想象一下，给一张桌子拍一张照片，纪录了桌子上所有物品的位置、状态，这样就可以称之为快照了。
>
> 我们不必存储所有的物品，只需存储这个照片就可以了，下一次想恢复以前的状态的时候，只需要翻出当时的那张照片，再把物品按照那张照片里的位置摆放一下就OK了。
>
> --来自V2EX：https://www.v2ex.com/t/124019

所以，对于 git 仓库，只需要将每一个文件的内容恢复到节点时的状态；对于文件系统，只需要将每个 block 的数据恢复到快照时的状态，这样就能完整还原当时的场景了。



在写完这段以后，我特地翻出去看了下维基百科上关于 snapshot 的解释：

![image-20221222154036757](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/image-20221222154036757.png)

**图 1. 维基百科对 snapshot 的解释 **



> - 照相术语，一张没有经过准备拍摄下来的照片就叫做 snapshot。
> - 计算机存储术语，snapshot 表示系统在某个特定时间点的状态。



![image-20221222154152598](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/image-20221222154152598.png)

**图 2. 维基百科对 Snapshot (computer storage) 的解释**



> 进一步解释 snapshot:
>
> 在计算机系统中，**快照**是系统在特定时间点的状态[。](https://en-m-wikipedia-org.translate.goog/wiki/State_(computer_science)?_x_tr_sl=auto&_x_tr_tl=zh-CN&_x_tr_hl=zh-CN&_x_tr_pto=wapp)该术语是作为摄影中的类比而创造的。它可以指系统状态的实际副本或某些系统提供的功能。

简直惊了个呆，对我来说，这里已经简简单单、明明白白地解释了什么是 snapshot，这天杀的墙~



另外，从这里也能看到，snapshot(快照) 和 photography(照相) 有些细微的区别:

![image-20221222154135096](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/image-20221222154135096.png)

**图 3. 维基百科对 Snapshot (Photography) 的解释**



其实我觉得维基百科中文页面的这个解释更接近我们的理解习惯:

![image-20221222160054303](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/image-20221222160054303.png)

**图 4. 维基百科对抓拍的解释**



所以，snapshot (快照) 实际上是对系统状态的抓拍，表示了系统在某个特定时间点的状态。



## 2. 快照 (snapshot) 的原理

这里讨论的快照 (snapshot) 实际上是指存储快照。

关于存储快照的原理，可以参考以下这几篇：

- 百度百科: [《存储快照》](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%BF%AB%E7%85%A7/5204871)
- 博客园文章: [《快照技术解析》](https://www.cnblogs.com/jing99/p/7446214.html), [《探究快照技术》](https://www.cnblogs.com/zhaochunhui/p/13597675.html)
- 华为企业服务网站: [《COW、ROW 快照技术原理》](https://support.huawei.com/enterprise/zh/doc/EDOC1100196336/)

前几篇从宏观上说明快照的基本原理，而[《COW、ROW快照技术原理》](https://support.huawei.com/enterprise/zh/doc/EDOC1100196336/)除了讲述原理外，更多地深入一层介绍了 COW 和 ROW 快照的读写操作细节。



有了上面这几篇之后，关于快照的原理其实不需要再啰嗦一遍了。但为了内容的完整性，这里还是再简要说明下，更多详细的内容请参考前面这几篇文章~



按照 SNIA 的定义, 快照有全量快照 (full snapshot) 和增量快照 (incremental snapshot) 两种类型, 其中又各自使用了不同的快照技术:

- 全量快照
  - 克隆 (Clone)
  - 镜像分离 (Split Mirror)
- 增量快照
  - 写时拷贝 COW (Copy-On-Write)
  - 写时重定向 ROW (Redirect-On-Write)

### 2.1 全量快照

#### 1. 克隆 (Clone)

克隆 (Clone) 快照创建的是数据的完整副本，快照的对象可以是一个存储卷、一个文件系统或者一个LUN，Clone 的优点就是具有高可用性，但是缺点也很明显，就是在创建的时候，数据要完整的复制一份。

使用克隆 (Clone) 快照需要面对的一个非常严重的问题是每个快照都需要占用和源数据空间一样大的存储空间。尤其对快照需求较大、较多的情况，资源成本会非常高。另外就是创建的时候消耗时间较长。



#### 2. 镜像分离 (Split Mirror)

镜像分离 (split mirror) 快照也属于全量快照，这种快照方式比较简单，先创建一个源卷的镜像卷，每次磁盘写入数据的时候，都会往源卷和快照卷同时写入内容。当启动快照时，则镜像卷能快速脱离，生成一个快照卷。

简而言之，镜像分离 (split mirror) 快照在读操作时没有任何影响，在写操作时会有两次写入操作，分别是写入源卷与镜像卷。



### 2.2 增量快照

#### 1. 写时拷贝(Copy-On-Write)

在源卷之外创建一个快照卷，用于存放快照数据。



##### **写数据**

在新数据第一次写入到源卷的某个存储位置时：

1. 先将原有的内容读取出来，写到快照卷中
2. 然后再将新数据写入到源卷的存储设备中。

操作 1 只在第一次写入数据时发生，下次针对这一位置的写操作直接将新数据写入到源卷中，不再执行写时复制操作。

![img](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/1010726-20170828225355655-1088905935.jpg)

**图 5. 写时拷贝 (COW) 模型**

> 图片来源: https://www.cnblogs.com/jing99/p/7446214.html



因此，**源卷存放的始终是当前的最新数据。**



##### **读数据**

如果需要访问某个时间点的快照数据:

- 对没有改变过的块直接从源卷读取
- 对已经改变并被复制的块则从快照卷读取

如果需要访问最新数据，直接从源卷读取。



##### **优缺点**

优点：COW 在进行快照操作之前，不会占用任何的存储资源，也不会影响系统性能。

缺点：

1. 降低源卷的写性能。当修改源数据时，会发生三次读写操作：

   1. 读取源数据。
   2. 将源数据写入快照卷中。
   3. 将新数据写入源卷中。

   如果写入数据频繁，那么这种方式将非常消耗I/O。

2. 没有快照完整的物理副本。快照卷仅仅保存了源卷的部分数据。

3. 拷贝到快照卷中的数据量超过了保留空间，快照就将失效。



#### 2. 写时重定向 (Redirect-On-Write)

ROW 的实现原理与 COW 非常相似，区别在于 ROW 对源卷的首次写操作，会将新数据重定向到预留的快照卷中。所以，ROW 快照中的原始数据依旧保留在源卷中，并且有些系统为了保证快照数据的完整性，在创建快照时，源卷状态会由读写变成只读。



##### **写数据**

在新数据第一次写入到源卷的某个存储位置时，将会被重定向写入到快照卷中。

当数据被再次改写时，系统会给更新过的数据在快照卷中选择一个新的存储位置，前一次写入重定向在快照卷中的数据得以保留，但不会被引用。



![img](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/1010726-20170828230100155-1585998507.jpg)

**图 6. 写时重定向 (ROW) 模型**

> 图片来源: https://www.cnblogs.com/jing99/p/7446214.html



因此，**源卷存放的始终是创建快照时的旧数据。**



##### **读数据**

如果需要访问某个时间点的快照数据，直接从源卷读取。

如果需要访问最新数据:

- 对没有改变过的块直接从源卷读取
- 对已经改变并被重定向的块则从快照卷读取



##### 优缺点

优点：不会降低源卷的写性能。源卷创建快照后的写操作会被重定向，所有的写 I/O 都被重定向到快照卷中，而所有快照数据(旧数据)均保留在源卷中。因此更新数据只需要一个写操作，解决了 COW 写两次的性能问题。

缺点：

1. 没有最新数据完整的物理副本。

   ROW 的快照卷保存了源卷改动后的新数据，但并不是完整的最新数据副本。因此，当创建了多个快照时，会产生一个快照链，源卷数据的变动追踪以及快照的删除将变得异常复杂。在恢复快照时会不断地合并快照文件，造成较大的系统开销。

2. 读性能下降。由于采用了重定向写，使得原本连续的数据分散到了磁盘中，连续写变成了随机写，造成读性能下降。



另外，由于源卷存放的是创建快照时的旧数据，为了让源卷得到更新后的数据，还需要执行一次合并操作，将快照卷中改动后的数据写回到源卷中。

## 3. Linux 快照 (snapshot)

基于快照的原理，可以有各种具体的实现，这里主要讨论 linux 系统中快照的实现。



### 3.1 Linux 快照的原理

Linux 下快照 (snapshot) 属于增量快照，基于 Device Mapper 驱动实现，快照设备是 Device Mapper 众多虚拟设备中的一种。



Device Mapper 对 snapshot 的支持，代码位于 `drivers/md` 目录，文档请考: 

`Documentation/admin-guide/device-mapper/snapshot.rst`

在线版本: https://docs.kernel.org/admin-guide/device-mapper/snapshot.html

> 如果 `Documentation/admin-guide` 目录不存在，请检查目录 `Documentation/device-mapper`。



> 如果您不想深入代码，但又希望透彻了解 snapshot，强烈建议看看这个文档。因为这是一手资料，网上所有其它解读都是二手了，包括本篇。
>
> **不懂看一手资料和二手资料有什么区别？微信转我 88，我来告诉你，别问为啥要 88 这么多，智商税。**
>
> 这个官方文档看不懂？那就去公众号加我微信讨论吧~



对于增量快照，除了源卷以外，不论是 COW 方式还是 ROW 方式都需要再分配一个快照卷。在 linux 中，这个快照卷统一被称为 COW 设备。

事实上，在 linux 的代码和文档中，甚至都没有 "ROW" 这样的字眼。正是因为理论上 snapshot 有 COW 和 ROW 两种方式，而在实际的 linux 驱动和文档中都没有看到，这一度让我走了不少弯路。

所以，linux 快照对 COW 和 ROW 两种方式都支持，只不过都称之为 Copy-On-Write 罢了。



对于 linux 下的 snapshot，其能够虚拟的 target device 有 3 类，分别是: snapshot-origin, snapshot 和 snapshot-merge。这 3 个设备对应于不同的场景：

- snapshot-origin，所有读取操作都直接映射到后端设备中，所谓后端设备，就是这里说的源卷。对每一次写入操作，原始数据(源卷中的旧数据)会被保存到 COW 设备中，新数据写入到源卷中。
- snapshot，所有写入操作的数据都保存到 COW 设备中。对于读取操作，如果数据没有改动，则从源卷读取数据; 如果数据改动了，则从 COW 设备读取数据；
- snapshot-merge，用于将 COW 设备中的数据合并 (merge) 回源卷中；

对 snapshot-origin 和 snapshot 设备的读写操作是不是有点眼熟？

没错，**snapshot-origin 设备对应于 COW 操作模型，snapshot 设备对应于 ROW 操作模型**。



这里假设有两个物理设备 source 和 cow，分别对应于源卷和快照卷。基于这两个物理设备虚拟出两个快照设备 snapshot-origin 和 snapshot，如下图所示:

> source 和 cow 本身也可以是虚拟设备(现实中 cow 基本都是虚拟设备)，这里为了方便描述，假定二者都为物理设备。



![COW-VS-ROW](images-20221221-Linux 存储快照(snapshot)原理与实践(一)/COW-VS-ROW.png)

**图 7. Linux 快照设备的 COW 和 ROW**



对于 snapshot-origin 设备，写入操作时，把原来 source 设备中的旧数据复制到 cow 设备中(步骤 1')，然后将新数据写入到 source 设备中(步骤 1）。读取操作则直接映射到 source 设备中(步骤 2)；



对于 snapshot 设备，写入操作时，直接将新数据写入到 cow 设备中(步骤 3)。读取时，没改动的数据映射到 source 设备(步骤 4'')，改动过的数据映射到 cow 设备中(步骤 4')。



另外，这里的 snapshot-origin 和 snapshot 虚拟设备可以同时存在，而且二者可以共用一个 cow 设备。因此，cow 设备中同时保存了 COW 和 ROW 操作的数据。



至于 snapshot-merge，其唯一的目的就是将快照卷 (cow) 中的数据合并 (merge) 回源卷 (source)，比如以下的这些场景:

- 对于 COW 操作，源卷始终保持最新数据，快照卷保存了旧数据，如果需要将源卷回滚到快照时间点的状态，就需要执行合并 (merge) 操作，将快照卷中的旧数据写回源卷。

- 对于 ROW 操作，源卷始终保持了快照时间点的状态，而快照卷保存了最新的数据，如果需要源卷更新到最新状态，也需要执行合并 (merge) 操作，将快照卷中的新数据写入到源卷。

一句话，COW 方式中对源卷还原 (还原到快照点)，或 ROW 方式中对源卷更新 (更新成最新数据)，都需要执行合并 (merge) 操作。Android 虚拟分区系统的更新就属于后者。



因此，对 snapshot-merge 设备，有一些特殊的要求：

- snapshot-merge 和 snapshot 使用同样的参数，只在持久快照 (persistent snapshot)下有效
- snapshot-merge 承担 snapshot-origin 的角色，如果源卷还存在 snapshot-origin 设备，则不得加载
- snapshot-merge 将快照卷 cow 中的更改块合并回源卷 source 中
- 合并开始以后，merge 之外的其它方式对源卷的修改将会被推迟到合并完成以后



这里解释了这么多，总结起来就是：

如果在 snapshot-origin 设备上操作，对应 COW 模型；

如果在 snapshot 设备上操作，对应 ROW 模型；

snapshot-merge 承担 snapshot-origin 的角色，将快照卷 cow 中的更改快合并回源卷 source 中；



### 3.2 COW 设备的数据结构

Linux 上的快照设备属于块设备，其最小的 block 单位为 sector，大小为 512 byte。

各种快照操作以 chunk 的方式进行，chunk 是比 sector 大的数据块，大小在创建 snapshot 时通过 chunksize 设置，比如设置 chunksize = 8，表明一个 1 x chunk = 8 x sector = 4KB。snapshot 驱动中默认的 chunksize 为 32，对应大小为 16KB。



对于 ROW 操作，如果修改源卷某个位置的数据，则数据所在的一整个 chunk 都会被写入到快照卷中。

那 COW 设备上的数据到底长什么样呢？



### 3.3 













