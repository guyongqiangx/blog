# Android 虚拟分区详解(四) 编译开关

![android_virtual_ab_3_title](/Volumes/work/guyongqiangx/draft/images-20221231-Android 虚拟分区详解(三)/android_virtual_ab_3_title.png)

> Android Virtual A/B 系统简称 VAB，我将其称为虚拟分区。
>
> 本系列文章基于 Android R(11) 进行分析，如果没有特别说明，均基于代码版本 android-11.0.0_r46



这一系列名为虚拟分区详解，到目前为止已经写了三篇了，从这一篇开始，逐步深入代码，从代码层面来讲解虚拟分区的代码实现。



本文主要讨论两个问题，虚拟分区 VAB 的编译开关，以及 Android 虚拟分区空间的计算。



关于虚拟分区实现的配置和各种注意事项，我在 [《Android 虚拟分区详解(一) 参考资料推荐》](https://blog.csdn.net/guyongqiangx/article/details/128071692)，首要参考的就是 Android 官方文档，值得反复阅读：

- Virtual A/B Overview

  - https://source.android.com/docs/core/ota/virtual_ab

  从比较宏观的层面综述 Virtual A/B 的功能。

  无梯子版本：https://source.android.google.cn/docs/core/ota/virtual_ab?hl=zh_cn

  

- Implementing Virtual A/B

  - https://source.android.com/docs/core/ota/virtual_ab/implement

  着重讲了 Virtual A/B 的编译开关，在各个组件(包括 BootCtl，fstab，Bootloader，kernel)中涉及的修改。

  无梯子版本：https://source.android.google.cn/docs/core/ota/virtual_ab/implement?hl=zh_cn

  

- Implementing Virtual A/B - Patches

  - https://source.android.com/docs/core/ota/virtual_ab/implement-patches

  讲了针对 Virtual A/B 推出以后发现问题提供的一些修复补丁(fix patch)。

  无梯子版本：https://source.android.google.cn/docs/core/ota/virtual_ab/implement-patches?hl=zh_cn



## Virtual A/B 的编译开关

### 1. 原生设备

在搭载 Android 11 及更高版本的设备上，Virtual A/B 是 GMS 的要求。所以如果你的设备需要过 GMS 认证，对 Android 11 及以后的设备，必须要支持 Virtual A/B。



一个系统要支持 Virtual A/B，是有前提条件的，官方的原话是：

> Devices that use virtual A/B must be **configured as an A/B device** and must **launch with dynamic partitions.**

按照这个说法：

1. 必须配置为 A/B 设备；
2. 搭载动态分区;

关于搭载动态分区，原话是 "launch with dynamic partitions"，意思就是原生支持动态分区的设备，例如出厂就支持动态分区的 Android Q(10)  或 R(11) 的设备。但对于一个从 Android P(9) 升级上来的设备，就不算是原生支持动态分区的设备。

所以，一台 Android P(9) 设备可以通过升级来支持 Virtual A/B 特性吗？不能！

但一台 Android Q(10) 设备可以通过升级来支持 Virtual A/B。



在 Android R(11) 中，一个设备要支持 Virtual A/B，只需要在打开了 A/B 系统和动态分区的开关之外，将其设置为设置为继承虚拟 A/B 设备即可，如下:

```makefile
$(call inherit-product, $(SRC_TARGET_DIR)/product/virtual_ab_ota.mk)
```

实际上等效于在 Makefile 中打开以下开关:

```bash
android-11.0.0_r46$ cat build/make/target/product/virtual_ab_ota.mk
#
# ...
#

PRODUCT_VIRTUAL_AB_OTA := true

PRODUCT_PROPERTY_OVERRIDES += ro.virtual_ab.enabled=true

PRODUCT_PACKAGES += e2fsck_ramdisk
```



> 思考题：
>
> 如何在一个系统运行时判断是否打开了 Virtual A/B?
>
> 答案就是检查系统属性中 virtual_ab 相关 property 的设置: `getprop | grep virtual_ab`



### 2. 升级设备

对于从 Android Q(10) 升级上来的设备，如果要改造支持 Virtual A/B，配置中包含以下文件即可:

```makefile
$(call inherit-product, $(SRC_TARGET_DIR)/product/virtual_ab_ota_retrofit.mk)
```

查看这个文件的内容，也比较简单，等效于在 virtual_ab_ota.mk 之外再打开两个 retrofit 开关:

```bash
$ cat build/make/target/product/virtual_ab_ota_retrofit.mk
#
# ...
#

$(call inherit-product, $(SRC_TARGET_DIR)/product/virtual_ab_ota.mk)

PRODUCT_VIRTUAL_AB_OTA_RETROFIT := true

PRODUCT_PROPERTY_OVERRIDES += ro.virtual_ab.retrofit=true
```



### 3. 编译开关的作用

从前面看到，Virtual A/B 原生设备和升级设备的开关都很简单。

对于原生设备，主要就是设置:

```makefile
PRODUCT_VIRTUAL_AB_OTA := true
```

对于升级设备，则是设置:

```makefile
PRODUCT_VIRTUAL_AB_OTA := true
PRODUCT_VIRTUAL_AB_OTA_RETROFIT := true
```

搜索 build 和 device 的代码，发现这两个 Makefile 变量唯一引用的地方在宏 dump-dynamic-partition-info 中:

![image-20230102232615912](images-20230102-Android 虚拟分区详解(四) 编译开关/image-20230102232615912.png)



Makefile 在编译过程中会调用宏 dump-dynamic-partition-info 将以下信息输出到各种 "*_info.txt" 文件中:

```bash
$ cat misc_info.txt 
...
virtual_ab=true
# 如果是改造设备
virtual_ab_retrofit=true
...
```

例如，会将这个信息输出到 

