# 20230328-lldb 命令用法速查

## 0. 背景

这里以 Ubuntu 20.04 下使用 lldb 调试 Android 11(R) 的 host 工具 lpdump 为例。

lldb 运行环境:

```bash
$ lsb_release -a
LSB Version:    core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch
Distributor ID: Ubuntu
Description:    Ubuntu 20.04.4 LTS
Release:        20.04
Codename:       focal
$ which lldb
/usr/bin/lldb
$ lldb --version
lldb version 10.0.1
```



使用 lldb 调试的 lpdump 命令为:

```bash
$ lpdump out/super_raw.img 
```

调试的 host 工具为 lpdum，带有 1 个参数 "out/super_raw.img"



## 1. 快捷列表



## 2. 详细说明

### 1. 本地如何启动 lldb 开始调试？

有很多种方式可以启动本地的 lldb 进行调试，下面列举常用的几种：

1. 直接在命令行执行 `lldb -- lpdump out/super_raw.img`

```bash
$ lldb -- lpdump out/super_raw.img 
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) settings set -- target.run-args  "out/super_raw.img"
(lldb) 
```

2. 执行 `lldb lpdump`，进入后使用 `settings` 命令提供参数

```bash
$ lldb lpdump
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) settings set target.run-args out/super_raw.img 
(lldb) 

# 查看设置的运行参数
(lldb) settings show target.run-args 
target.run-args (array of strings) =
  [0]: "out/super_raw.img"
(lldb) 
```

3. 执行 `lldb lpdump`，进入后设置断点，并通过 `run` 命令提供参数

```bash
$ lldb lpdump
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) b main
Breakpoint 1: where = lpdump`main at lpdump_host.cc:20:12, address = 0x00000000000018c0
(lldb) run out/super_raw.img 
Process 2048340 launched: '/local/public/users/ygu/android-r/src-vab/out/soong/host/linux-x86/bin/lpdump' (x86_64)
Process 2048340 stopped
* thread #1, name = 'lpdump', stop reason = breakpoint 1.1
    frame #0: 0x00005555555558c0 lpdump`main(argc=2, argv=0x00007fffffffd2f8) at lpdump_host.cc:20:12
   17   int LpdumpMain(int argc, char* argv[]);
   18  
   19   int main(int argc, char* argv[]) {
-> 20       return LpdumpMain(argc, argv);
   21   }
(lldb) 
```

如果进入 lldb 后就执行 `run out/super_raw.img`， 程序 lpdump 直接就运行了，不会停下来，所以需要先使用 `b main` 在 main 函数的入口处设置一个断点，当执行 run 命令时会在 main 函数开始的地方停下来。



> 仔细观察，实际上对于命令: `lldb -- lpdump out/super_raw.img`，在运行lldb 时被分解为多个步骤了：
>
> 1. 执行 lldb 进入 lldb 调试模式
> 2. 在 lldb 命令行执行命令: `target create "lpdump"`
> 3. 在 lldb 命令行执行命令: `settings set target.run-args out/super_raw.img `

### 2. 如何退出 lldb 调试

在 lldb 命令行使用 `exit` 或 `quit` 退出调试。

如果在调试对象还在运行，则会有消息提示，选择 Y 结束调试，退出 lldb。

```bash
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] Y
```

如果调试对象已经结束，则直接退出 lldb。



1. 使用 exit 退出调试

```bash
# 使用 exit 退出调试
$ lldb -- lpdump out/super_raw.img 
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) settings set -- target.run-args  "out/super_raw.img"
(lldb) b main
Breakpoint 1: where = lpdump`main at lpdump_host.cc:20:12, address = 0x00000000000018c0
(lldb) run
Process 2050133 launched: '/local/public/users/ygu/android-r/src-vab/out/soong/host/linux-x86/bin/lpdump' (x86_64)
Process 2050133 stopped
* thread #1, name = 'lpdump', stop reason = breakpoint 1.1
    frame #0: 0x00005555555558c0 lpdump`main(argc=2, argv=0x00007fffffffd2f8) at lpdump_host.cc:20:12
   17   int LpdumpMain(int argc, char* argv[]);
   18  
   19   int main(int argc, char* argv[]) {
-> 20       return LpdumpMain(argc, argv);
   21   }
(lldb) exit
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] Y
$ 
```



2. 使用 quit 退出调试

```bash
# 使用 quit 退出调试
$ lldb -- lpdump out/super_raw.img 
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) settings set -- target.run-args  "out/super_raw.img"
(lldb) run
Process 2051836 launched: '/local/public/users/ygu/android-r/src-vab/out/soong/host/linux-x86/bin/lpdump' (x86_64)
lpdump E 03-28 10:56:17 2051836 2051836 reader.cpp:443] [liblp]std::unique_ptr<LpMetadata> android::fs_mgr::ReadMetadata(const android::fs_mgr::IPartitionOpener &, const std::string &, uint32_t) open failed: out/super_raw.img: No such file or directory
Failed to read metadata.
Process 2051836 exited with status = 66 (0x00000042) 
(lldb) quit
$ 
```



### 3. 如何开始执行程序?

进入 lldb 后，如果已经设置好调试的程序和参数，运行 `run` 命令执行程序，如果没有设置断点，则程序直接运行到结束或异常的地方。

如果此前没有设置过运行的参数，可以通过 `run` 命令提供参数，如`run out/super_raw.img`；如果已经提供了参数，直接执行 `run` 命令。



1. 没有设置断点，lpdump 直接运行到异常的地方

```bash
$ lldb lpdump
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) run out/super_raw.img 
Process 2056950 launched: '/local/public/users/ygu/android-r/src-vab/out/soong/host/linux-x86/bin/lpdump' (x86_64)
lpdump E 03-28 11:09:19 2056950 2056950 reader.cpp:443] [liblp]std::unique_ptr<LpMetadata> android::fs_mgr::ReadMetadata(const android::fs_mgr::IPartitionOpener &, const std::string &, uint32_t) open failed: out/super_raw.img: No such file or directory
Failed to read metadata.
Process 2056950 exited with status = 66 (0x00000042) 
(lldb) 
```



2. 先在 main 函数设置断点，运行 `run` 命令在 main 函数开始的地方停下来，等待下一步指令

```bash
$ lldb -- lpdump out/super_raw.img 
(lldb) target create "lpdump"
Current executable set to 'lpdump' (x86_64).
(lldb) settings set -- target.run-args  "out/super_raw.img"
(lldb) b main
Breakpoint 1: where = lpdump`main at lpdump_host.cc:20:12, address = 0x00000000000018c0
(lldb) run
Process 2053614 launched: '/local/public/users/ygu/android-r/src-vab/out/soong/host/linux-x86/bin/lpdump' (x86_64)
Process 2053614 stopped
* thread #1, name = 'lpdump', stop reason = breakpoint 1.1
    frame #0: 0x00005555555558c0 lpdump`main(argc=2, argv=0x00007fffffffd2f8) at lpdump_host.cc:20:12
   17   int LpdumpMain(int argc, char* argv[]);
   18  
   19   int main(int argc, char* argv[]) {
-> 20       return LpdumpMain(argc, argv);
   21   }
(lldb) 
```



### 4. 如何单步执行程序?

简单来说，单步执行有两种方式，分别是 next(n) 和 step(s)。

二者的区别在于，

- 执行 next 时，如果当前是函数，则跳转到函数的下一行；如果当前是循环，则跳转到循环结束的下一行；

- 执行 step 时，如果当前是函数，则进入到函数的第一条语句；如果当前是循环，则进入循环的第一条语句。



### 5. 如何结束当前函数的执行？

使用 `finish` 命令结束当前函数，并返回上一层。

```bash
```



### 如何显示源码？

如果执行了其它命令后，不知道当前运行到什么位置了，可以使用 bt 查看下当前的堆栈情况，然后使用 `list [行号]` 显示指定行号附近的源码，例如:

```bash
(lldb) bt
* thread #1, name = 'lpdump', stop reason = step over
  * frame #0: 0x00007ffff7ede52e liblpdump.so`LpdumpMain(argc=2, argv=0x00007fffffffd2f8, cout=0x00007ffff7ecde30, cerr=0x00007ffff7ecdf70) at lpdump.cc:467:9
    frame #1: 0x00007ffff7a65083 libc.so.6`__libc_start_main(main=(lpdump`main at lpdump_host.cc:20:12), argc=2, argv=0x00007fffffffd2f8, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffd2e8) at libc-start.c:308:16
    frame #2: 0x00005555555557b9 lpdump`_start + 41
(lldb) list lpdump.cc:467
   467      if (!slot.has_value()) {
   468          slot = 0;
   469      }
   470 
   471      // Determine the path to the super partition (or image). If an explicit
   472      // path is given, we use it for everything. Otherwise, we will infer it
   473      // at the time we need to read metadata.
   474      std::string super_path;
   475      bool override_super_name = (optind < argc);
   476      if (override_super_name) {
   477          super_path = argv[optind++];
(lldb) 
```

这里 bt 输出第 2 行显示当前栈帧 0 位于 lpdump.cc:467 行：

```bash
  * frame #0: 0x00007ffff7ede52e liblpdump.so`LpdumpMain(argc=2, argv=0x00007fffffffd2f8, cout=0x00007ffff7ecde30, cerr=0x00007ffff7ecdf70) at lpdump.cc:467:9
```

因此，使用 `list lpdump:cc:467` 查看这个位置的源码。



### 如何打印变量？

### 如何添加和删除断点？



## 3. 重点：如何才能掌握 lldb 进行调试？

