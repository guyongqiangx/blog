# Android 动态分区详解（三）

## 1. 导读

关于 Android 的各种特性，永远建议首先参考官方文档，包括两类:

- 一类是代码中自带的文档，包括模块中 README.md, HIDL 和 头文件中的注释等

- 另一类是 Android 官方网站: https://source.android.com/

这里重点说下第二个，现在官方网站上的文档是越来越丰富了。我刚开始分析 A/B 系统的时候，官方文档屈指可数，也没有中文版。现在文档很多，感觉似乎各个模块都有，而且还配有多语言版本，很大程度上可以解决 "my english is poor" 问题。

如果发现有神秘力量导致无法访问官方网站，现在也可以访问无障碍版本: https://source.android.google.cn/

当我真正开始写关于 Android 动态分区配置介绍的时候，又去认真看了一眼官方介绍动态分区的页面，只能一声感叹，"卧槽~"。我想说的，官方网站早就说了，以至于我都不知道该写些什么。

>  Android 官方介绍动态分区的链接：
>
> [《实现动态分区》(https://source.android.com/devices/tech/ota/dynamic_partitions/implement)](https://source.android.com/devices/tech/ota/dynamic_partitions/implement)

官方页面从比较高的角度综述了 Android 动态分区的各个方面，包括基本原理(一笔带过)，配置说明，注意事项等，其目的还是给大家介绍如何使用动态分区，而不是重点强调原理。

本文重点介绍 Android 动态分区的配置，包括原生动态分区和改造动态分区的配置，以及这些配置是如何起作用的。

在开始我关于动态分区配置介绍之前，我再建议您先仔细阅读下官方文档(那篇文档值得反复阅读)，然后再开始本文。

## 2. Android 动态分区配置



### 2.1 动态分区配置

```makefile
# device/google/cuttlefish/shared/BoardConfig.mk
ifeq ($(TARGET_USE_DYNAMIC_PARTITIONS),true)
  BOARD_SUPER_PARTITION_SIZE := 6442450944
  BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
  BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
  BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 6442450944
  BOARD_SUPER_PARTITION_METADATA_DEVICE := vda
  BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT := true
  BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE := true
  TARGET_RELEASETOOLS_EXTENSIONS := device/google/cuttlefish/shared
else
  # No dynamic partitions support; we must specify maximum sizes
  BOARD_SYSTEMIMAGE_PARTITION_SIZE := 4294967296 # 4 GB
  BOARD_VENDORIMAGE_PARTITION_SIZE := 536870912 # 512MB
  BOARD_PRODUCTIMAGE_PARTITION_SIZE := 1610612736 # 1.5GB
  TARGET_NO_RECOVERY ?= true
endif
```

### 2.2 改造动态分区配置

所谓改造动态分区，就是从不支持动态分区到支持动态分区的改动，比如从 Android P 升级到 Android Q。

```makefile
# device/google/crosshatch/BoardConfig-common.mk
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS), true)
BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := \
    system \
    vendor \
    product

ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS), true)
# Normal Pixel 3 must retrofit dynamic partitions.
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800
# Assume 4MB metadata size.
# TODO(b/117997386): Use correct metadata size.
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
else
# Mainline Pixel 3 has an actual super partition.

# TODO (b/136154856) product_services partition is removed.
# Instead, we will add system_ext once it is ready.
# BOARD_PRODUCT_SERVICESIMAGE_FILE_SYSTEM_TYPE := ext4
# TARGET_COPY_OUT_PRODUCT_SERVICES := product_services

BOARD_SUPER_PARTITION_SIZE := 12884901888
# Assume 1MB metadata size.
# TODO(b/117997386): Use correct metadata size.
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 6441402368

# TODO (b/136154856) product_services partition removed.
# Instead, we will add system_ext once it is ready.
# BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST += \
#    product_services \

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
endif # PRODUCT_USE_DYNAMIC_PARTITIONS
```



### 2.3 动态分区参数检查

#### 参数设置检查

```makefile
# build/make/core/config.mk
# 1. 设置了改造动态分区 PRODUCT_RETROFIT_DYNAMIC_PARTITIONS = true, 则必须设置总开关为 true:
#    PRODUCT_USE_DYNAMIC_PARTITIONS = true
ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS),true)
  ifneq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
    $(error PRODUCT_USE_DYNAMIC_PARTITIONS must be true when PRODUCT_RETROFIT_DYNAMIC_PARTITIONS \
        is set)
  endif
  ifdef PRODUCT_SHIPPING_API_LEVEL
    ifeq (true,$(call math_gt_or_eq,$(PRODUCT_SHIPPING_API_LEVEL),29))
      $(error Devices with shipping API level $(PRODUCT_SHIPPING_API_LEVEL) must not set \
          PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)
    endif
  endif
endif

# 2. 设置了总开关 PRODUCT_USE_DYNAMIC_PARTITIONS = true, 则:
#    - 不能再设置 BOARD_BUILD_SYSTEM_ROOT_IMAGE = true,
#    - 必须设置 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
    ifeq ($(BOARD_BUILD_SYSTEM_ROOT_IMAGE),true)
        $(error BOARD_BUILD_SYSTEM_ROOT_IMAGE cannot be true for devices with dynamic partitions)
    endif
    ifneq ($(PRODUCT_USE_DYNAMIC_PARTITION_SIZE),true)
        $(error PRODUCT_USE_DYNAMIC_PARTITION_SIZE must be true for devices with dynamic partitions)
    endif
endif

# 3. 设置了 PRODUCT_BUILD_SUPER_PARTITION = true, 则:
#    - 必须设置 PRODUCT_USE_DYNAMIC_PARTITIONS = true
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)
    ifneq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
        $(error Can only build super partition for devices with dynamic partitions)
    endif
endif

# 4. 设置了 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true 的前提下, 
#    分区列表(system, vendor, odm, product, product_service) 的大小参数:
#    BOARD_$(device)_PARTITION_SIZE 和 BOARD_$(device)_PARTITION_RESERVED_SIZE 只能设置一个
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITION_SIZE),true)

# 4.1 BOARD_SYSTEMIMAGE_PARTITION_SIZE 和 BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_SYSTEMIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_SYSTEMIMAGE_PARTITION_SIZE and \
    BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.2 BOARD_VENDORIMAGE_PARTITION_SIZE 和 BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_VENDORIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_VENDORIMAGE_PARTITION_SIZE and \
    BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.3 BOARD_ODMIMAGE_PARTITION_SIZE 和 BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_ODMIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_ODMIMAGE_PARTITION_SIZE and \
    BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.4 BOARD_PRODUCTIMAGE_PARTITION_SIZE 和 BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_PRODUCTIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_PRODUCTIMAGE_PARTITION_SIZE and \
    BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.5 BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE 和 BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE and \
    BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

endif # PRODUCT_USE_DYNAMIC_PARTITION_SIZE

# 5. 设置了 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true 的前提下, 
#    需要设置以下分组列表(google_dynamic_partitions) 的参数:
#    - BOARD_$(group)_PARTITION_LIST,
#    - BOARD_$(group)_SIZE, 
#    - BOARD_$(group)_PARTITION_PARTITION_LIST
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)

# BOARD_SUPER_PARTITION_GROUPS defines a list of "updatable groups". Each updatable group is a
# group of partitions that share the same pool of free spaces.
# For each group in BOARD_SUPER_PARTITION_GROUPS, a BOARD_{GROUP}_SIZE and
# BOARD_{GROUP}_PARTITION_PARTITION_LIST may be defined.
#     - BOARD_{GROUP}_SIZE: The maximum sum of sizes of all partitions in the group.
#       Must not be empty.
#     - BOARD_{GROUP}_PARTITION_PARTITION_LIST: the list of partitions that belongs to this group.
#       If empty, no partitions belong to this group, and the sum of sizes is effectively 0.
# 5.1 如果没有设置过 BOARD_$(group)_PARTITION_LIST, 则默认为空，不包含任何分区
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(eval BOARD_$(group)_PARTITION_LIST ?=) \
    $(eval .KATI_READONLY := BOARD_$(group)_PARTITION_LIST) \
)
# 5.2 如果设置了 PRODUCT_BUILD_SUPER_PARTITION = true, 则设置:
#     BOARD_$(group)_SIZE, 例如: BOARD_SUPER_SIZE, 且不能为空。
#     实际上 PRODUCT_BUILD_SUPER_PARTITION 在 product_config.mk 会被设置为 PRODUCT_BUILD_SUPER_PARTITION 相同值
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(eval BOARD_$(group)_SIZE := $(strip $(BOARD_$(group)_SIZE))) \
    $(if $(BOARD_$(group)_SIZE),,$(error BOARD_$(group)_SIZE must not be empty)) \
    $(eval .KATI_READONLY := BOARD_$(group)_SIZE) \
)
endif # PRODUCT_BUILD_SUPER_PARTITION

# 6. BOARD_SUPER_PARTITION_GROUPS 不能设置为列表(system vendor product product_services odm)中的名字
# BOARD_*_PARTITION_LIST: a list of the following tokens
valid_super_partition_list := system vendor product product_services odm
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(if $(filter-out $(valid_super_partition_list),$(BOARD_$(group)_PARTITION_LIST)), \
        $(error BOARD_$(group)_PARTITION_LIST contains invalid partition name \
            $(filter-out $(valid_super_partition_list),$(BOARD_$(group)_PARTITION_LIST)). \
            Valid names are $(valid_super_partition_list))))
valid_super_partition_list :=

# 7. 不能定义 BOARD_SUPER_PARTITION_PARTITION_LIST，该值通过计算获得
# Define BOARD_SUPER_PARTITION_PARTITION_LIST, the sum of all BOARD_*_PARTITION_LIST
ifdef BOARD_SUPER_PARTITION_PARTITION_LIST
$(error BOARD_SUPER_PARTITION_PARTITION_LIST should not be defined, but computed from \
    BOARD_SUPER_PARTITION_GROUPS and BOARD_*_PARTITION_LIST)
endif
BOARD_SUPER_PARTITION_PARTITION_LIST := \
    $(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
        $(BOARD_$(group)_PARTITION_LIST))
.KATI_READONLY := BOARD_SUPER_PARTITION_PARTITION_LIST

endif # PRODUCT_USE_DYNAMIC_PARTITIONS
```

#### 分区大小检查

```makefile
```



### 2.4 原生和改造动态分区的统一

```makefile
# build/make/core/config.mk
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)

#
# 1. 改造支持动态分区的情况
#    - 设置了 BOARD_SUPER_PARTITION_SIZE, 
#      如: BOARD_SUPER_PARTITION_SIZE := 4072669184
#    - 并且 PRODUCT_RETROFIT_DYNAMIC_PARTITIONS == true
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)
ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS),true)

# 1.1 必须设置 BOARD_SUPER_PARTITION_METADATA_DEVICE, 
#     如: BOARD_SUPER_PARTITION_METADATA_DEVICE := system
# The metadata device must be specified manually for retrofitting.
ifeq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),)
$(error Must specify BOARD_SUPER_PARTITION_METADATA_DEVICE if PRODUCT_RETROFIT_DYNAMIC_PARTITIONS=true.)
endif

# 1.2 必须设置 BOARD_SUPER_PARTITION_BLOCK_DEVICES
#     如: BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
# The super partition block device list must be specified manually for retrofitting.
ifeq ($(BOARD_SUPER_PARTITION_BLOCK_DEVICES),)
$(error Must specify BOARD_SUPER_PARTITION_BLOCK_DEVICES if PRODUCT_RETROFIT_DYNAMIC_PARTITIONS=true.)
endif

# 1.3 metadata 分区必须要包含在 super 分区的 block devices 列表中
# The metadata device must be included in the super partition block device list.
ifeq (,$(filter $(BOARD_SUPER_PARTITION_METADATA_DEVICE),$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)))
$(error BOARD_SUPER_PARTITION_METADATA_DEVICE is not listed in BOARD_SUPER_PARTITION_BLOCK_DEVICES.)
endif

# 1.4 metadata 分区必须传递给 kernel 的命令行启动参数: androidboot.super_partition
# The metadata device must be supplied to init via the kernel command-line.
INTERNAL_KERNEL_CMDLINE += androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)

# 1.5 生成 RETROFIT 相关的 OTA 包
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE := true

# If "vendor" is listed as one of the dynamic partitions but without its image available (e.g. an
# AOSP target built without vendor image), don't build the retrofit full OTA package. Because we
# won't be able to build meaningful super_* images for retrofitting purpose.
ifneq (,$(filter vendor,$(BOARD_SUPER_PARTITION_PARTITION_LIST)))
ifndef BUILDING_VENDOR_IMAGE
ifndef BOARD_PREBUILT_VENDORIMAGE
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=
endif # BOARD_PREBUILT_VENDORIMAGE
endif # BUILDING_VENDOR_IMAGE
endif # BOARD_SUPER_PARTITION_PARTITION_LIST

else # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
#
# 2. 原生动态分区的情况
#
# For normal devices, we populate BOARD_SUPER_PARTITION_BLOCK_DEVICES so the
# build can handle both cases consistently.

# 2.1 默认将 metadata device 设置为 super 分区
ifeq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),)
BOARD_SUPER_PARTITION_METADATA_DEVICE := super
endif

# 2.2 将 super 分区设置为 BOARD_SUPER_PARTITION_BLOCK_DEVICES
ifeq ($(BOARD_SUPER_PARTITION_BLOCK_DEVICES),)
BOARD_SUPER_PARTITION_BLOCK_DEVICES := $(BOARD_SUPER_PARTITION_METADATA_DEVICE)
endif

# 2.3 检查 block devices 分区数量, 如果只有一个 super 分区，则设置:
#     BOARD_SUPER_PARTITION_SUPER_DEVICE_SIZE ?= $(BOARD_SUPER_PARTITION_SIZE)
#     函数 $(word 2,$(list), 返回列表中变量 list 中的第 2 个 word, 如果没有，则为空。
# If only one super block device, default to super partition size.
ifeq ($(word 2,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)),)
BOARD_SUPER_PARTITION_$(call to-upper,$(strip $(BOARD_SUPER_PARTITION_BLOCK_DEVICES)))_DEVICE_SIZE ?= \
    $(BOARD_SUPER_PARTITION_SIZE)
endif

# 2.4 将 super 分区必须传递给 kernel 的命令行启动参数: androidboot.super_partition=super
ifneq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),super)
INTERNAL_KERNEL_CMDLINE += androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)
endif

# 2.5 不生成 RETROFIT 相关的 OTA 包
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
endif # BOARD_SUPER_PARTITION_SIZE
.KATI_READONLY := BOARD_SUPER_PARTITION_BLOCK_DEVICES
.KATI_READONLY := BOARD_SUPER_PARTITION_METADATA_DEVICE
.KATI_READONLY := BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE

#
# 3. 将 block devices 列表展开，检查列表中的每个分区是否已经设置了分区大小
#    如: BOARD_SUPER_PARTITION_BLOCK_DEVICES = system vendor product，则展开成 3 个变量:
#        BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE,
#        BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE,
#        BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE
$(foreach device,$(call to-upper,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)), \
    $(eval BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE := $(strip $(BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE))) \
    $(if $(BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE),, \
        $(error BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE must not be empty)) \
    $(eval .KATI_READONLY := BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE))

endif # PRODUCT_BUILD_SUPER_PARTITION
```

所以实际上动态分区最终需要以下这一组参数:



对于原生动态分区为：

```makefile
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := super
BOARD_SUPER_PARTITION_BLOCK_DEVICES := super
BOARD_SUPER_PARTITION_SUPER_DEVICE_SIZE := 4072669184
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=
```

对于改造动态分区为:

```makefile
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE := true
```

### 2.5 分区参数是如何生效的？

```makefile
# $(1): file
define dump-dynamic-partitions-info
  $(if $(filter true,$(PRODUCT_USE_DYNAMIC_PARTITIONS)), \
    echo "use_dynamic_partitions=true" >> $(1))
  $(if $(filter true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)), \
    echo "dynamic_partition_retrofit=true" >> $(1))
  echo "lpmake=$(notdir $(LPMAKE))" >> $(1)
  $(if $(filter true,$(PRODUCT_BUILD_SUPER_PARTITION)), $(if $(BOARD_SUPER_PARTITION_SIZE), \
    echo "build_super_partition=true" >> $(1)))
  $(if $(filter true,$(BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE)), \
    echo "build_retrofit_dynamic_partitions_ota_package=true" >> $(1))
  echo "super_metadata_device=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)" >> $(1)
  $(if $(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
    echo "super_block_devices=$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)" >> $(1))
  $(foreach device,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
    echo "super_$(device)_device_size=$(BOARD_SUPER_PARTITION_$(call to-upper,$(device))_DEVICE_SIZE)" >> $(1);)
  $(if $(BOARD_SUPER_PARTITION_PARTITION_LIST), \
    echo "dynamic_partition_list=$(BOARD_SUPER_PARTITION_PARTITION_LIST)" >> $(1))
  $(if $(BOARD_SUPER_PARTITION_GROUPS),
    echo "super_partition_groups=$(BOARD_SUPER_PARTITION_GROUPS)" >> $(1))
  $(foreach group,$(BOARD_SUPER_PARTITION_GROUPS), \
    echo "super_$(group)_group_size=$(BOARD_$(call to-upper,$(group))_SIZE)" >> $(1); \
    $(if $(BOARD_$(call to-upper,$(group))_PARTITION_LIST), \
      echo "super_$(group)_partition_list=$(BOARD_$(call to-upper,$(group))_PARTITION_LIST)" >> $(1);))
  $(if $(filter true,$(TARGET_USERIMAGES_SPARSE_EXT_DISABLED)), \
    echo "build_non_sparse_super_partition=true" >> $(1))
  $(if $(filter true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE)), \
    echo "super_image_in_update_package=true" >> $(1))
endef
```

示例参数:

```bash
$ cat out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt
use_dynamic_partitions=true
lpmake=lpmake
build_super_partition=true
super_metadata_device=super
super_block_devices=super
super_super_device_size=3028287488
dynamic_partition_list= system vendor
super_partition_groups=bcm_ref
super_bcm_ref_group_size=1509949440
super_bcm_ref_partition_list=system vendor
ab_update=true
system_image=out/target/product/inuvik/system.img
vendor_image=out/target/product/inuvik/vendor.img
```

### 2.6 原生动态分区 super.img 的生成

#### 2.6.1 dist 模式下 super.img

dist 模式下基于 `out/target/product/inuvik/obj/PACKAGING/target_files_intermediates/inuvik-target_files-eng.rg935739.zip` 的内容生成 super.img。

主要由 superimage_dist 目标构成依赖关系。

```makefile
# -----------------------------------------------------------------
# super partition image (dist)

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))

# BOARD_SUPER_PARTITION_SIZE must be defined to build super image.
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)

# Dump variables used by build_super_image.py.
define dump-super-image-info
  $(call dump-dynamic-partitions-info,$(1))
  $(if $(filter true,$(AB_OTA_UPDATER)), \
    echo "ab_update=true" >> $(1))
endef

# 1. 原生动态分区
ifneq (true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS))

# For real devices and for dist builds, build super image from target files to an intermediate directory.
# out/target/product/inuvik/obj/PACKAGING/super.img_intermediates/super.img
INTERNAL_SUPERIMAGE_DIST_TARGET := $(call intermediates-dir-for,PACKAGING,super.img)/super.img
$(INTERNAL_SUPERIMAGE_DIST_TARGET): extracted_input_target_files := $(patsubst %.zip,%,$(BUILT_TARGET_FILES_PACKAGE))
# 1.1 调用 build_super_image.py 生成 super.img
$(INTERNAL_SUPERIMAGE_DIST_TARGET): $(LPMAKE) $(BUILT_TARGET_FILES_PACKAGE) $(BUILD_SUPER_IMAGE)
	$(call pretty,"Target super fs image from target files: $@")
	PATH=$(dir $(LPMAKE)):$$PATH \
	    $(BUILD_SUPER_IMAGE) -v $(extracted_input_target_files) $@

# Skip packing it in dist package because it is in update package.
ifneq (true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE))
$(call dist-for-goals,dist_files,$(INTERNAL_SUPERIMAGE_DIST_TARGET))
endif

.PHONY: superimage_dist
superimage_dist: $(INTERNAL_SUPERIMAGE_DIST_TARGET)

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS != "true"
endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"
```

#### 2.6.2 debug 模式下 super.img

debug 模式下基于 `out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt`文件的内容生成 super.img。

主要由 droidcore 或 superimage 构成依赖关系。

```bash
# misc_info.txt
$ cat out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt
use_dynamic_partitions=true
lpmake=lpmake
build_super_partition=true
super_metadata_device=super
super_block_devices=super
super_super_device_size=3028287488
dynamic_partition_list= system vendor
super_partition_groups=bcm_ref
super_bcm_ref_group_size=1509949440
super_bcm_ref_partition_list=system vendor
ab_update=true
system_image=out/target/product/inuvik/system.img
vendor_image=out/target/product/inuvik/vendor.img
```



生成 super.img 的逻辑:

```makefile
# -----------------------------------------------------------------
# super partition image for development

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)
ifneq (true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS))

# Build super.img by using $(INSTALLED_*IMAGE_TARGET) to $(1)
# $(1): built image path
# $(2): misc_info.txt path; its contents should match expectation of build_super_image.py
define build-superimage-target
  mkdir -p $(dir $(2))
  rm -rf $(2)
  $(call dump-super-image-info,$(2))
  $(foreach p,$(BOARD_SUPER_PARTITION_PARTITION_LIST), \
    echo "$(p)_image=$(INSTALLED_$(call to-upper,$(p))IMAGE_TARGET)" >> $(2);)
  mkdir -p $(dir $(1))
  PATH=$(dir $(LPMAKE)):$$PATH \
    $(BUILD_SUPER_IMAGE) -v $(2) $(1)
endef

# out/target/product/inuvik/super.img
INSTALLED_SUPERIMAGE_TARGET := $(PRODUCT_OUT)/super.img
INSTALLED_SUPERIMAGE_DEPENDENCIES := $(LPMAKE) $(BUILD_SUPER_IMAGE) \
    $(foreach p, $(BOARD_SUPER_PARTITION_PARTITION_LIST), $(INSTALLED_$(call to-upper,$(p))IMAGE_TARGET))

# If BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT is set, super.img is built from images in the
# $(PRODUCT_OUT) directory, and is built to $(PRODUCT_OUT)/super.img. Also, it will
# be built for non-dist builds. This is useful for devices that uses super.img directly, e.g.
# virtual devices.
ifeq (true,$(BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT))
$(INSTALLED_SUPERIMAGE_TARGET): $(INSTALLED_SUPERIMAGE_DEPENDENCIES)
	$(call pretty,"Target super fs image for debug: $@")
	$(call build-superimage-target,$(INSTALLED_SUPERIMAGE_TARGET),\
	  $(call intermediates-dir-for,PACKAGING,superimage_debug)/misc_info.txt)

droidcore: $(INSTALLED_SUPERIMAGE_TARGET)

# For devices that uses super image directly, the superimage target points to the file in $(PRODUCT_OUT).
.PHONY: superimage
superimage: $(INSTALLED_SUPERIMAGE_TARGET)
endif # BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT

# Build $(PRODUCT_OUT)/super.img without dependencies.
.PHONY: superimage-nodeps supernod
superimage-nodeps supernod: intermediates :=
superimage-nodeps supernod: | $(INSTALLED_SUPERIMAGE_DEPENDENCIES)
	$(call pretty,"make $(INSTALLED_SUPERIMAGE_TARGET): ignoring dependencies")
	$(call build-superimage-target,$(INSTALLED_SUPERIMAGE_TARGET),\
	  $(call intermediates-dir-for,PACKAGING,superimage-nodeps)/misc_info.txt)

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS != "true"
endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"
```

#### 2.6.4 super_empty.img

基于 `out/target/product/inuvik/obj/PACKAGING/super_empty_intermediates/misc_info.txt` 文件生成 super_empty.img。

通过调用 `main.mk` 中的 superimage_empty 目标形成依赖关系。

```makefile
# -----------------------------------------------------------------
# super empty image

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)

INSTALLED_SUPERIMAGE_EMPTY_TARGET := $(PRODUCT_OUT)/super_empty.img
$(INSTALLED_SUPERIMAGE_EMPTY_TARGET): intermediates := $(call intermediates-dir-for,PACKAGING,super_empty)
$(INSTALLED_SUPERIMAGE_EMPTY_TARGET): $(LPMAKE) $(BUILD_SUPER_IMAGE)
	$(call pretty,"Target empty super fs image: $@")
	mkdir -p $(intermediates)
	rm -rf $(intermediates)/misc_info.txt
	$(call dump-super-image-info,$(intermediates)/misc_info.txt)
	PATH=$(dir $(LPMAKE)):$$PATH \
	    $(BUILD_SUPER_IMAGE) -v $(intermediates)/misc_info.txt $@

$(call dist-for-goals,dist_files,$(INSTALLED_SUPERIMAGE_EMPTY_TARGET))

endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"

```

#### 2.6.5 目标依赖关系:

```makefile
$(DEFAULT_GOAL): droid_targets

droid_targets: droidcore dist_files

# dist
$(call dist-for-goals,dist_files,$(INTERNAL_SUPERIMAGE_DIST_TARGET))
# debug
droidcore: $(INSTALLED_SUPERIMAGE_TARGET)
# empty
$(call dist-for-goals,dist_files,$(INSTALLED_SUPERIMAGE_EMPTY_TARGET))

# dist
superimage_dist: $(INTERNAL_SUPERIMAGE_DIST_TARGET)
# debug
superimage: $(INSTALLED_SUPERIMAGE_TARGET)
# empty
superimage_empty: $(INSTALLED_SUPERIMAGE_EMPTY_TARGET)
```



关于 `dist-for-goals` 宏定义:

```makefile
# Other parts of the system should use this function to associate
# certain files with certain goals.  When those goals are built
# and "dist" is specified, the marked files will be copied to DIST_DIR.
#
# $(1): a list of goals  (e.g. droid, sdk, pdk, ndk). These must be PHONY
# $(2): the dist files to add to those goals.  If the file contains ':',
#       the text following the colon is the name that the file is copied
#       to under the dist directory.  Subdirs are ok, and will be created
#       at copy time if necessary.
define dist-for-goals
$(if $(strip $(2)), \
  $(eval _all_dist_goals += $$(1))) \
$(foreach file,$(2), \
  $(eval src := $(call word-colon,1,$(file))) \
  $(eval dst := $(call word-colon,2,$(file))) \
  $(if $(dst),,$(eval dst := $$(notdir $$(src)))) \
  $(eval _all_dist_src_dst_pairs += $$(src):$$(dst)) \
  $(foreach goal,$(1), \
    $(eval _all_dist_goal_output_pairs += $$(goal):$$(dst))))
endef
```

### 2.7 OTA  package 包含的内容

```makefile
# -----------------------------------------------------------------
# The update package

name := $(TARGET_PRODUCT)
ifeq ($(TARGET_BUILD_TYPE),debug)
  name := $(name)_debug
endif
name := $(name)-img-$(FILE_NAME_TAG)

INTERNAL_UPDATE_PACKAGE_TARGET := $(PRODUCT_OUT)/$(name).zip

$(INTERNAL_UPDATE_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(ZIP2ZIP)

ifeq (true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE))
$(INTERNAL_UPDATE_PACKAGE_TARGET): $(INTERNAL_SUPERIMAGE_DIST_TARGET)
	@echo "Package: $@"
	# Filter out super_empty and images in BOARD_SUPER_PARTITION_PARTITION_LIST.
	# Filter out system_other for launch DAP devices because it is in super image.
	# Include OTA/super_*.img for retrofit devices and super.img for non-retrofit
	# devices.
	$(hide) $(ZIP2ZIP) -i $(BUILT_TARGET_FILES_PACKAGE) -o $@ \
	  -x IMAGES/super_empty.img \
	  $(foreach partition,$(BOARD_SUPER_PARTITION_PARTITION_LIST), \
	    -x IMAGES/$(partition).img) \
	  $(if $(filter system, $(BOARD_SUPER_PARTITION_PARTITION_LIST)), \
	    $(if $(filter true, $(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)),, \
	      -x IMAGES/system_other.img)) \
	  $(if $(filter true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)), \
	    $(foreach device,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
	      OTA/super_$(device).img:super_$(device).img)) \
	  OTA/android-info.txt:android-info.txt "IMAGES/*.img:."
	$(if $(INTERNAL_SUPERIMAGE_DIST_TARGET), zip -q -j -u $@ $(INTERNAL_SUPERIMAGE_DIST_TARGET))
else
$(INTERNAL_UPDATE_PACKAGE_TARGET):
	@echo "Package: $@"
	$(hide) $(ZIP2ZIP) -i $(BUILT_TARGET_FILES_PACKAGE) -o $@ \
	  OTA/android-info.txt:android-info.txt "IMAGES/*.img:."
endif # BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE

.PHONY: updatepackage
updatepackage: $(INTERNAL_UPDATE_PACKAGE_TARGET)
```

