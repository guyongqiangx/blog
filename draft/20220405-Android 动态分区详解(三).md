# Android 动态分区详解（三）

## 1. 导读

关于 Android 的各种特性，永远建议首先参考官方文档，包括两类:

- 一类是代码中自带的文档，包括模块中 README.md, HIDL 和 头文件中的注释等

- 另一类是 Android 官方网站: https://source.android.com/

这里重点说下第二个，现在官方网站上的文档是越来越丰富了。我刚开始分析 A/B 系统的时候，官方文档屈指可数，也没有中文版。现在文档很多，感觉似乎各个模块都有，而且还配有多语言版本，很大程度上可以解决 "my english is poor" 问题。

如果发现有神秘力量导致无法访问官方网站，现在也可以访问无障碍版本: https://source.android.google.cn/

当我真正开始写关于 Android 动态分区配置介绍的时候，又认真看了一遍官方介绍动态分区的页面，只能一声感叹，"卧槽~"。我想说的，官方网站早就说了，以至于我都不知道还能写些什么。

>  Android 官方介绍动态分区的链接：
>
> [《实现动态分区》(https://source.android.com/devices/tech/ota/dynamic_partitions/implement)](https://source.android.com/devices/tech/ota/dynamic_partitions/implement)

官方页面从比较高的角度综述了 Android 动态分区，包括基本原理，配置说明，注意事项等，目的还是给大家介绍如何使用动态分区，重点不在于强调原理。

本文根据设备是否存在 super 分区，将包含 super 分区的称为**原生动态分区**，对应于 Android 的默认动态分区配置；将从低版本升级上来不包含 super 分区的称为**改造动态分区**，对应于 retrofit 的配置。

本文重点介绍 Android 动态分区的这编译配置，这些配置是如何生效，super.img 又是如何生成的。

如果您之前没有阅读过上面说的 [《实现动态分区》](https://source.android.com/devices/tech/ota/dynamic_partitions/implement)，在开始本文之前，我再建议您先仔细阅读下(官方这篇值得反复阅读)，以及本动态分区详解系列的第一篇[《Android 动态分区详解(一)》](https://blog.csdn.net/guyongqiangx/article/details/123899602)，然后再开始本文。

> 本文基于 android-10.0.0_r47 代码进行分析

## 2. Android 动态分区配置

### 2.1 动态分区配置选项

根据[《实现动态分区》](https://source.android.com/devices/tech/ota/dynamic_partitions/implement)里讲述的，将动态分区需要设置的项列举如下。

#### 2.1.1 原生动态分区配置

对于**原生动态分区**，需要以下设置:

```makefile
# 动态分区总开关
PRODUCT_USE_DYNAMIC_PARTITIONS := true

# 设置 super 分区大小
BOARD_SUPER_PARTITION_SIZE := <size-in-bytes>

# 设置分区组, 可以设置多个组，对于 A/B 设备，每组最终会有 _a 和 _b 两个 slot
# 这里以分区组 group_foo 为例，会生成 group_foo_a 和 group_foo_b 两个组
BOARD_SUPER_PARTITION_GROUPS := group_foo

# 设置分区组包含的分区, 这里包含 system, vendor 和 product 等 3 个分区
BOARD_GROUP_FOO_PARTITION_LIST := system vendor product

# 设置分区组总大小, 总大小需要能够放下分区组里面的所有分区
BOARD_GROUP_FOO_SIZE := <size-in-bytes>

# 启用块级重复信息删除，可以进一步压缩 ext4 映像
BOARD_EXT4_SHARE_DUP_BLOCKS := true
```



#### 2.1.2 改造动态分区配置

对于**改造动态分区(retrofit)**, 需要以下设置:

```makefile
# 改造(retrofit)动态分区总开关, 这里多了一个 retrofit，标明是升级改造设备
PRODUCT_USE_DYNAMIC_PARTITIONS := true
PRODUCT_RETROFIT_DYNAMIC_PARTITIONS := true

# 设置为所有动态分区内子分区大小的总和
BOARD_SUPER_PARTITION_SIZE := <size-in-bytes>

# 设置动态分区子分区, 这里包含 system, vendor 和 product 等 3 个分区
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product

# 逐个设置每一个子分区大小, 这设置 system, vendor 分区大小 
# BOARD_SUPER_PARTITION_$(partition)_DEVICE_SIZE
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := <size-in-bytes>
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := <size-in-bytes>

# 设置分区组, 可以设置多个组，每组最终会有 _a 和 _b 两个 slot
BOARD_SUPER_PARTITION_GROUPS := group_foo

# 设置分区组包含的分区, 这里包含 system, vendor 和 product 等 3 个分区
BOARD_GROUP_FOO_PARTITION_LIST := system vendor product

# 设置分区组总大小, 总大小需要能够放下分区组里面的所有分区
BOARD_GROUP_FOO_SIZE := <size-in-bytes>

# 指定 metadata 数据存放的设备，这里设置为 system 分区，也可以是单独的分区
BOARD_SUPER_PARTITION_METADATA_DEVICE := system

# 启用块级重复信息删除，可以进一步压缩 ext4 映像
BOARD_EXT4_SHARE_DUP_BLOCKS := true
```

这里特别说明的是，改造动态分区时，需要通过 `BOARD_SUPER_PARTITION_METADATA_DEVICE` 指定 metadata 存放的分区。因此，不仅可以将 metadata 数据和某个分区放到一起，例如原生动态分区中就是将 metadata 和 super 分区放到一起；也可以将 metadata 数据单独放到某个分区中，例如 cuttlefish 模拟器中就是将 metadata 单独存放在名为 vda 的分区中 。

#### 2.1.3 动态分区配置注意事项

1. 在动态分区配置中，不再需要以下分区大小设置了，例如：

```makefile
BOARD_SYSTEMIMAGE_PARTITION_SIZE := 4294967296 # 4 GB
BOARD_VENDORIMAGE_PARTITION_SIZE := 536870912 # 512MB
BOARD_PRODUCTIMAGE_PARTITION_SIZE := 1610612736 # 1.5GB
```

2. 原生动态分区中，super 分区内的 system, vendor, product 等需要从 GPT 分区表中移除
3. 应避免将 userdata, cache 或任何其他永久性读写分区放在 super 分区中

### 2.2 动态分区配置示例

关于动态分区配置，这里再以三个 AOSP 自带的 google 设备动态分区配置为例说明，包括原生动态分区和改造动态分区(retrofit)，这部分配置位于 `device/google` 目录之下。

#### 2.2.1 crosshatch 设备(Pixel 3 XL)配置示例

crosshatch 设备(Pixel 3 XL) 支持原生动态分区，也支持改造动态分区，配置如下：

```makefile
# device/google/crosshatch/BoardConfig-common.mk
ifneq ($(PRODUCT_USE_DYNAMIC_PARTITIONS), true)
  # ...
else
  BOARD_EXT4_SHARE_DUP_BLOCKS := true
endif

ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS), true)
BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := \
    system \
    vendor \
    product

ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS), true)
# Normal Pixel 3 must retrofit dynamic partitions.
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800
# Assume 4MB metadata size.
# TODO(b/117997386): Use correct metadata size.
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
else
# Mainline Pixel 3 has an actual super partition.

# TODO (b/136154856) product_services partition is removed.
# Instead, we will add system_ext once it is ready.
# BOARD_PRODUCT_SERVICESIMAGE_FILE_SYSTEM_TYPE := ext4
# TARGET_COPY_OUT_PRODUCT_SERVICES := product_services

BOARD_SUPER_PARTITION_SIZE := 12884901888
# Assume 1MB metadata size.
# TODO(b/117997386): Use correct metadata size.
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 6441402368

# TODO (b/136154856) product_services partition removed.
# Instead, we will add system_ext once it is ready.
# BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST += \
#    product_services \

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
endif # PRODUCT_USE_DYNAMIC_PARTITIONS
```

crosshatch 动态分区总体上，设备定义了 1 个动态分区组 `google_dynamic_partitions`, 包含分区 `system vendor product`。

对于原生动态分区，有：

```makefile
# 启用块级重复信息删除，可以进一步压缩 ext4 映像
BOARD_EXT4_SHARE_DUP_BLOCKS := true

# 总开关
PRODUCT_USE_DYNAMIC_PARTITIONS := true
# 分区组和子分区
BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
# super 分区和分区组大小
BOARD_SUPER_PARTITION_SIZE := 12884901888
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 6441402368
```

对于改造动态分区，有:

```makefile
# 启用块级重复信息删除，可以进一步压缩 ext4 映像
BOARD_EXT4_SHARE_DUP_BLOCKS := true

# 总开关
PRODUCT_USE_DYNAMIC_PARTITIONS := true
PRODUCT_RETROFIT_DYNAMIC_PARTITIONS := true
# 分区组和子分区
BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
# super 分区大小
BOARD_SUPER_PARTITION_SIZE := 4072669184
# metadata 存放的设备
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
# 动态分区内的子分区
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
# 每个子分区大小
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016  # 2816M
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368   # 768M
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800  # 300M
# 分区组大小
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
```

#### 2.2.2 bonito 设备(Pixel 3a XL)配置示例

bonito 设备(Pixel 3a XL)只支持改造动态分区，配置如下：

```makefile
# device/google/bonito/device-common.mk
# Enable retrofit dynamic partitions for all bonito
# and sargo targets
PRODUCT_USE_DYNAMIC_PARTITIONS := true
PRODUCT_RETROFIT_DYNAMIC_PARTITIONS := true

# device/google/bonito/BoardConfig-common.mk
BOARD_EXT4_SHARE_DUP_BLOCKS := true
BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := \
    system \
    vendor \
    product

BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 3267362816
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
# Assume 4MB metadata size.
# TODO(b/117997386): Use correct metadata size.
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4068474880
```

从这里的配置看，和 crosshatch 设备(Pixel 3 XL)对改造动态分区的配置是一样的，只是少了一个 product 分区。


#### 2.2.3 模拟器 cuttlefish 配置示例

模拟器 cuttlefish 的动态分区配置位于文件: `device/google/cuttlefish/shared/BoardConfig.mk`，如下：

```makefile
# device/google/cuttlefish/shared/BoardConfig.mk
ifeq ($(TARGET_USE_DYNAMIC_PARTITIONS),true)
  BOARD_SUPER_PARTITION_SIZE := 6442450944
  BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
  BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
  BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 6442450944
  BOARD_SUPER_PARTITION_METADATA_DEVICE := vda
  BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT := true
  BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE := true
  TARGET_RELEASETOOLS_EXTENSIONS := device/google/cuttlefish/shared
else
  # ...
endif
```

这里是模拟 cuttlefish 原生动态分区的配置，重点如下:

- 不带 `PRODUCT_RETROFIT_DYNAMIC_PARTITIONS`, 原生动态分区
- super 分区大小为 6442450944
- 定义了一个动态分区组 `google_dynamic_partitions`, 大小为 6442450944, 包含三个子分区 `system vendor product`
- 指定了 metadata 数据存放的分区 vda

另外：

- `BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT := true` 指定了 super.img 由 `$(PRODUCT_OUT)` 目录下的文件创建，并输出到 `$(PRODUCT_OUT)/super.img` 中

> 注意: 上面的 cuttlefish 的例子中，
>
> 1. 使用自定义的 `TARGET_USE_DYNAMIC_PARTITIONS` 作为开关，而不是 `PRODUCT_USE_DYNAMIC_PARTITIONS`, 不过后者会根据前者设置为 true
> 2. `BOARD_SUPER_PARTITION_SIZE` 和 `BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE` 一样，都是 6442450944，所以 cuttlefish 模拟器应该不是 A/B 设备。A/B 设备下要求动态分区组大小为：`(super 分区大小 - 开销) / 2`

### 2.3 动态分区参数检查

设置了动态分区参数以后，Android 在编译时会对参数进行检查，检查的内容包括两类：

- 开关参数检查，检查动态分区的配置开关是否冲突

- 分区大小参数的检查，检查分区大小设置是否符合要求

我本来对这几段 Makefile 代码做了注释，但因为很长，贴上的话整篇文章就更啰嗦了，所以这里直接贴上结论把。

#### 2.3.1 开关参数检查

文件 `build/make/core/config.mk` 的 811~878 行，对动态分区的开关参数进行检查。

> 参考链接: http://aospxref.com/android-10.0.0_r47/xref/build/make/core/config.mk#811

这段代码检查的重点有:

- 改造动态分区开关和动态分区总开关必须同时设置

  ```makefile
  # 总开关
  PRODUCT_USE_DYNAMIC_PARTITIONS := true
  # 改造(retrofit)动态分区开关
  PRODUCT_RETROFIT_DYNAMIC_PARTITIONS := true
  ```

- 打开了动态分区之后，列表(system, vendor, odm, product, product_services)对应分区的以下 SIZE 配置不能同时设置

  ```makefile
  # (system, vendor, odm, product, product_services)
  BOARD_$(device)IMAGE_PARTITION_SIZE
  BOARD_$(device)IMAGE_PARTITION_RESERVED_SIZE
  ```

- 对每一个分组 group，需要同时设置 `PARTITION_LIST` 和 `SIZE` 参数

  ```makefile
  BOARD_$(group)_PARTITION_LIST
  BOARD_$(group)_SIZE
  ```

- 如果分组没有设置 `BOARD_$(group)_PARTITION_LIST`, 则默认分组内没有分区

- 分组名 `BOARD_SUPER_PARTITION_GROUPS` 不能设置为列表(system vendor product product_services odm)中的名字

- 打开动态分区后，不需要再设置 `BOARD_BUILD_SYSTEM_ROOT_IMAGE = true`

#### 2.3.2 分区大小限制

文件 `build/make/core/Makefile` 的 3375~3485 行，定义了多个宏对动态分区以及子分区的大小进行检查。

> 参考链接: http://aospxref.com/android-10.0.0_r47/xref/build/make/core/Makefile#3375

详细的代码比较繁琐，主要是各分区或分组大小数值的计算和比较。

这里原文引用一下[《实现动态分区》](https://source.android.com/devices/tech/ota/dynamic_partitions/implement)中说的动态分区大小限制：


> - 对于虚拟 A/B 启动设备，所有组的最大大小总和不得超过：
>   *`BOARD_SUPER_PARTITION_SIZE` - 开销*
> - 对于 A/B 启动设备，所有组的最大大小总和必须为：
>   *`BOARD_SUPER_PARTITION_SIZE`/ 2 - 开销*
> - 对于非 A/B 设备和改造的 A/B 设备，所有组的大小上限总和必须为：
>   *`BOARD_SUPER_PARTITION_SIZE` - 开销*
> - 在构建时，更新组中每个分区的映像大小总和不得超过组的大小上限。
> - 在计算时需要扣除开销，因为要考虑元数据、对齐等。合理的开销是 4 MiB，但您可以根据设备的需要选择更大的开销。

这里说下上面提到的 4M 总开销的来源，主要有两类：

- 元数据(metadata)开销，元数据位于分区开始的 4KB~1MB 范围内
- 分区对齐开销，默认分区按照 1MB 对齐

如果动态分区中定义了一个分区组，包含三个分区(system, vendor, product)，对于 A/B 系统，分区组会有两个槽位，因此一共有 6 个子分区。按中值计算，平均每个子分区对齐开销为 0.5M，这样 6 个分区对齐，一共需要 0.5M x 6 = 3M 的总对齐开销。再加上元数据(metadata) 1M 的开销，所以预估 `4M = 1M + 0.5M x 6` 的总开销是合理的。

## 3. Android 动态分区参数的处理

### 3.1 原生和改造动态分区两套参数的合并

前面第 2 节提到，对于原生动态分区和改造动态分区，需要进行不同的参数设置。

文件 `build/make/core/config.mk` 的 923~994行，代码将原生动态分区和改造动态分区的两组参数合并成一组参数进行了处理。

> 参考链接: http://aospxref.com/android-10.0.0_r47/xref/build/make/core/config.mk#923

以 `2.2.1 crosshatch 设备(Pixel 3 XL)配置示例` 节提到的原生动态分区和改造动态分区参数为例，经过处理，最终得到以下的动态分区参数。

对于原生动态分区为:

```makefile
PRODUCT_USE_DYNAMIC_PARTITIONS := true

BOARD_EXT4_SHARE_DUP_BLOCKS := true

BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := super

BOARD_SUPER_PARTITION_BLOCK_DEVICES := super
BOARD_SUPER_PARTITION_SUPER_DEVICE_SIZE := 4072669184

BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456

BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=

INTERNAL_KERNEL_CMDLINE += \
		androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)
```

对于改造动态分区为:

```makefile
PRODUCT_USE_DYNAMIC_PARTITIONS := true
PRODUCT_RETROFIT_DYNAMIC_PARTITIONS := true

BOARD_EXT4_SHARE_DUP_BLOCKS := true

BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system

BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800

BOARD_SUPER_PARTITION_GROUPS := google_dynamic_partitions
BOARD_GOOGLE_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456

BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE := true

INTERNAL_KERNEL_CMDLINE += \
		androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)
```

在这里，这两套参数最终合并成了一套参数。

### 3.2 动态分区参数是如何生效的？

上一节提到原生动态分区和改造动态分区的不同设置最终会合并成对同一组参数的设置。

那转换成这同一组参数后，后续是如何处理的呢？



在 `build/make/core/Makefile` 中定义了一个宏函数 `dump-dynamic-partitions-info`，用于将原生动态分区相关信息输出到指定的文件中，如下:

```makefile
# $(1): file
define dump-dynamic-partitions-info
  $(if $(filter true,$(PRODUCT_USE_DYNAMIC_PARTITIONS)), \
    echo "use_dynamic_partitions=true" >> $(1))
  $(if $(filter true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)), \
    echo "dynamic_partition_retrofit=true" >> $(1))
  echo "lpmake=$(notdir $(LPMAKE))" >> $(1)
  $(if $(filter true,$(PRODUCT_BUILD_SUPER_PARTITION)), $(if $(BOARD_SUPER_PARTITION_SIZE), \
    echo "build_super_partition=true" >> $(1)))
  $(if $(filter true,$(BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE)), \
    echo "build_retrofit_dynamic_partitions_ota_package=true" >> $(1))
  echo "super_metadata_device=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)" >> $(1)
  $(if $(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
    echo "super_block_devices=$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)" >> $(1))
  $(foreach device,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
    echo "super_$(device)_device_size=$(BOARD_SUPER_PARTITION_$(call to-upper,$(device))_DEVICE_SIZE)" >> $(1);)
  $(if $(BOARD_SUPER_PARTITION_PARTITION_LIST), \
    echo "dynamic_partition_list=$(BOARD_SUPER_PARTITION_PARTITION_LIST)" >> $(1))
  $(if $(BOARD_SUPER_PARTITION_GROUPS),
    echo "super_partition_groups=$(BOARD_SUPER_PARTITION_GROUPS)" >> $(1))
  $(foreach group,$(BOARD_SUPER_PARTITION_GROUPS), \
    echo "super_$(group)_group_size=$(BOARD_$(call to-upper,$(group))_SIZE)" >> $(1); \
    $(if $(BOARD_$(call to-upper,$(group))_PARTITION_LIST), \
      echo "super_$(group)_partition_list=$(BOARD_$(call to-upper,$(group))_PARTITION_LIST)" >> $(1);))
  $(if $(filter true,$(TARGET_USERIMAGES_SPARSE_EXT_DISABLED)), \
    echo "build_non_sparse_super_partition=true" >> $(1))
  $(if $(filter true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE)), \
    echo "super_image_in_update_package=true" >> $(1))
endef
```



```bash
$ cat out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt
use_dynamic_partitions=true
lpmake=lpmake
build_super_partition=true
super_metadata_device=super
super_block_devices=super
super_super_device_size=3028287488
dynamic_partition_list= system vendor
super_partition_groups=bcm_ref
super_bcm_ref_group_size=1509949440
super_bcm_ref_partition_list=system vendor
ab_update=true
system_image=out/target/product/inuvik/system.img
vendor_image=out/target/product/inuvik/vendor.img
```

## 4. 原生动态分区 super.img 的生成

#### 2.6.1 dist 模式下 super.img

dist 模式下基于 `out/target/product/inuvik/obj/PACKAGING/target_files_intermediates/inuvik-target_files-eng.rg935739.zip` 的内容生成 super.img。

主要由 superimage_dist 目标构成依赖关系。

```makefile
# -----------------------------------------------------------------
# super partition image (dist)

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))

# BOARD_SUPER_PARTITION_SIZE must be defined to build super image.
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)

# Dump variables used by build_super_image.py.
define dump-super-image-info
  $(call dump-dynamic-partitions-info,$(1))
  $(if $(filter true,$(AB_OTA_UPDATER)), \
    echo "ab_update=true" >> $(1))
endef

# 1. 原生动态分区
ifneq (true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS))

# For real devices and for dist builds, build super image from target files to an intermediate directory.
# out/target/product/inuvik/obj/PACKAGING/super.img_intermediates/super.img
INTERNAL_SUPERIMAGE_DIST_TARGET := $(call intermediates-dir-for,PACKAGING,super.img)/super.img
$(INTERNAL_SUPERIMAGE_DIST_TARGET): extracted_input_target_files := $(patsubst %.zip,%,$(BUILT_TARGET_FILES_PACKAGE))
# 1.1 调用 build_super_image.py 生成 super.img
$(INTERNAL_SUPERIMAGE_DIST_TARGET): $(LPMAKE) $(BUILT_TARGET_FILES_PACKAGE) $(BUILD_SUPER_IMAGE)
	$(call pretty,"Target super fs image from target files: $@")
	PATH=$(dir $(LPMAKE)):$$PATH \
	    $(BUILD_SUPER_IMAGE) -v $(extracted_input_target_files) $@

# Skip packing it in dist package because it is in update package.
ifneq (true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE))
$(call dist-for-goals,dist_files,$(INTERNAL_SUPERIMAGE_DIST_TARGET))
endif

.PHONY: superimage_dist
superimage_dist: $(INTERNAL_SUPERIMAGE_DIST_TARGET)

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS != "true"
endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"
```

#### 2.6.2 debug 模式下 super.img

debug 模式下基于 `out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt`文件的内容生成 super.img。

主要由 droidcore 或 superimage 构成依赖关系。

```bash
# misc_info.txt
$ cat out/target/product/inuvik/obj/PACKAGING/superimage_debug_intermediates/misc_info.txt
use_dynamic_partitions=true
lpmake=lpmake
build_super_partition=true
super_metadata_device=super
super_block_devices=super
super_super_device_size=3028287488
dynamic_partition_list= system vendor
super_partition_groups=bcm_ref
super_bcm_ref_group_size=1509949440
super_bcm_ref_partition_list=system vendor
ab_update=true
system_image=out/target/product/inuvik/system.img
vendor_image=out/target/product/inuvik/vendor.img
```



生成 super.img 的逻辑:

```makefile
# -----------------------------------------------------------------
# super partition image for development

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)
ifneq (true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS))

# Build super.img by using $(INSTALLED_*IMAGE_TARGET) to $(1)
# $(1): built image path
# $(2): misc_info.txt path; its contents should match expectation of build_super_image.py
define build-superimage-target
  mkdir -p $(dir $(2))
  rm -rf $(2)
  $(call dump-super-image-info,$(2))
  $(foreach p,$(BOARD_SUPER_PARTITION_PARTITION_LIST), \
    echo "$(p)_image=$(INSTALLED_$(call to-upper,$(p))IMAGE_TARGET)" >> $(2);)
  mkdir -p $(dir $(1))
  PATH=$(dir $(LPMAKE)):$$PATH \
    $(BUILD_SUPER_IMAGE) -v $(2) $(1)
endef

# out/target/product/inuvik/super.img
INSTALLED_SUPERIMAGE_TARGET := $(PRODUCT_OUT)/super.img
INSTALLED_SUPERIMAGE_DEPENDENCIES := $(LPMAKE) $(BUILD_SUPER_IMAGE) \
    $(foreach p, $(BOARD_SUPER_PARTITION_PARTITION_LIST), $(INSTALLED_$(call to-upper,$(p))IMAGE_TARGET))

# If BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT is set, super.img is built from images in the
# $(PRODUCT_OUT) directory, and is built to $(PRODUCT_OUT)/super.img. Also, it will
# be built for non-dist builds. This is useful for devices that uses super.img directly, e.g.
# virtual devices.
ifeq (true,$(BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT))
$(INSTALLED_SUPERIMAGE_TARGET): $(INSTALLED_SUPERIMAGE_DEPENDENCIES)
	$(call pretty,"Target super fs image for debug: $@")
	$(call build-superimage-target,$(INSTALLED_SUPERIMAGE_TARGET),\
	  $(call intermediates-dir-for,PACKAGING,superimage_debug)/misc_info.txt)

droidcore: $(INSTALLED_SUPERIMAGE_TARGET)

# For devices that uses super image directly, the superimage target points to the file in $(PRODUCT_OUT).
.PHONY: superimage
superimage: $(INSTALLED_SUPERIMAGE_TARGET)
endif # BOARD_BUILD_SUPER_IMAGE_BY_DEFAULT

# Build $(PRODUCT_OUT)/super.img without dependencies.
.PHONY: superimage-nodeps supernod
superimage-nodeps supernod: intermediates :=
superimage-nodeps supernod: | $(INSTALLED_SUPERIMAGE_DEPENDENCIES)
	$(call pretty,"make $(INSTALLED_SUPERIMAGE_TARGET): ignoring dependencies")
	$(call build-superimage-target,$(INSTALLED_SUPERIMAGE_TARGET),\
	  $(call intermediates-dir-for,PACKAGING,superimage-nodeps)/misc_info.txt)

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS != "true"
endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"
```

#### 2.6.4 super_empty.img

基于 `out/target/product/inuvik/obj/PACKAGING/super_empty_intermediates/misc_info.txt` 文件生成 super_empty.img。

通过调用 `main.mk` 中的 superimage_empty 目标形成依赖关系。

```makefile
# -----------------------------------------------------------------
# super empty image

ifeq (true,$(PRODUCT_BUILD_SUPER_PARTITION))
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)

INSTALLED_SUPERIMAGE_EMPTY_TARGET := $(PRODUCT_OUT)/super_empty.img
$(INSTALLED_SUPERIMAGE_EMPTY_TARGET): intermediates := $(call intermediates-dir-for,PACKAGING,super_empty)
$(INSTALLED_SUPERIMAGE_EMPTY_TARGET): $(LPMAKE) $(BUILD_SUPER_IMAGE)
	$(call pretty,"Target empty super fs image: $@")
	mkdir -p $(intermediates)
	rm -rf $(intermediates)/misc_info.txt
	$(call dump-super-image-info,$(intermediates)/misc_info.txt)
	PATH=$(dir $(LPMAKE)):$$PATH \
	    $(BUILD_SUPER_IMAGE) -v $(intermediates)/misc_info.txt $@

$(call dist-for-goals,dist_files,$(INSTALLED_SUPERIMAGE_EMPTY_TARGET))

endif # BOARD_SUPER_PARTITION_SIZE != ""
endif # PRODUCT_BUILD_SUPER_PARTITION == "true"

```

#### 2.6.5 目标依赖关系:

```makefile
$(DEFAULT_GOAL): droid_targets

droid_targets: droidcore dist_files

# dist
$(call dist-for-goals,dist_files,$(INTERNAL_SUPERIMAGE_DIST_TARGET))
# debug
droidcore: $(INSTALLED_SUPERIMAGE_TARGET)
# empty
$(call dist-for-goals,dist_files,$(INSTALLED_SUPERIMAGE_EMPTY_TARGET))

# dist
superimage_dist: $(INTERNAL_SUPERIMAGE_DIST_TARGET)
# debug
superimage: $(INSTALLED_SUPERIMAGE_TARGET)
# empty
superimage_empty: $(INSTALLED_SUPERIMAGE_EMPTY_TARGET)
```



关于 `dist-for-goals` 宏定义:

```makefile
# Other parts of the system should use this function to associate
# certain files with certain goals.  When those goals are built
# and "dist" is specified, the marked files will be copied to DIST_DIR.
#
# $(1): a list of goals  (e.g. droid, sdk, pdk, ndk). These must be PHONY
# $(2): the dist files to add to those goals.  If the file contains ':',
#       the text following the colon is the name that the file is copied
#       to under the dist directory.  Subdirs are ok, and will be created
#       at copy time if necessary.
define dist-for-goals
$(if $(strip $(2)), \
  $(eval _all_dist_goals += $$(1))) \
$(foreach file,$(2), \
  $(eval src := $(call word-colon,1,$(file))) \
  $(eval dst := $(call word-colon,2,$(file))) \
  $(if $(dst),,$(eval dst := $$(notdir $$(src)))) \
  $(eval _all_dist_src_dst_pairs += $$(src):$$(dst)) \
  $(foreach goal,$(1), \
    $(eval _all_dist_goal_output_pairs += $$(goal):$$(dst))))
endef
```

### 2.7 OTA  package 包含的内容

```makefile
# -----------------------------------------------------------------
# The update package

name := $(TARGET_PRODUCT)
ifeq ($(TARGET_BUILD_TYPE),debug)
  name := $(name)_debug
endif
name := $(name)-img-$(FILE_NAME_TAG)

INTERNAL_UPDATE_PACKAGE_TARGET := $(PRODUCT_OUT)/$(name).zip

$(INTERNAL_UPDATE_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(ZIP2ZIP)

ifeq (true,$(BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE))
$(INTERNAL_UPDATE_PACKAGE_TARGET): $(INTERNAL_SUPERIMAGE_DIST_TARGET)
	@echo "Package: $@"
	# Filter out super_empty and images in BOARD_SUPER_PARTITION_PARTITION_LIST.
	# Filter out system_other for launch DAP devices because it is in super image.
	# Include OTA/super_*.img for retrofit devices and super.img for non-retrofit
	# devices.
	$(hide) $(ZIP2ZIP) -i $(BUILT_TARGET_FILES_PACKAGE) -o $@ \
	  -x IMAGES/super_empty.img \
	  $(foreach partition,$(BOARD_SUPER_PARTITION_PARTITION_LIST), \
	    -x IMAGES/$(partition).img) \
	  $(if $(filter system, $(BOARD_SUPER_PARTITION_PARTITION_LIST)), \
	    $(if $(filter true, $(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)),, \
	      -x IMAGES/system_other.img)) \
	  $(if $(filter true,$(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)), \
	    $(foreach device,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES), \
	      OTA/super_$(device).img:super_$(device).img)) \
	  OTA/android-info.txt:android-info.txt "IMAGES/*.img:."
	$(if $(INTERNAL_SUPERIMAGE_DIST_TARGET), zip -q -j -u $@ $(INTERNAL_SUPERIMAGE_DIST_TARGET))
else
$(INTERNAL_UPDATE_PACKAGE_TARGET):
	@echo "Package: $@"
	$(hide) $(ZIP2ZIP) -i $(BUILT_TARGET_FILES_PACKAGE) -o $@ \
	  OTA/android-info.txt:android-info.txt "IMAGES/*.img:."
endif # BOARD_SUPER_IMAGE_IN_UPDATE_PACKAGE

.PHONY: updatepackage
updatepackage: $(INTERNAL_UPDATE_PACKAGE_TARGET)
```

---

## 附录

### 2.3 动态分区参数检查

我在下面添加代码的注释，比较啰嗦冗长，不关心细节的请跳转到总结一节看结论。

#### 开关参数检查

在 `build/make/core/config.mk` 的

```makefile
# build/make/core/config.mk
# 1. 设置了改造动态分区 PRODUCT_RETROFIT_DYNAMIC_PARTITIONS = true, 则必须设置总开关为 true:
#    PRODUCT_USE_DYNAMIC_PARTITIONS = true
ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS),true)
  ifneq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
    $(error PRODUCT_USE_DYNAMIC_PARTITIONS must be true when PRODUCT_RETROFIT_DYNAMIC_PARTITIONS \
        is set)
  endif
  ifdef PRODUCT_SHIPPING_API_LEVEL
    ifeq (true,$(call math_gt_or_eq,$(PRODUCT_SHIPPING_API_LEVEL),29))
      $(error Devices with shipping API level $(PRODUCT_SHIPPING_API_LEVEL) must not set \
          PRODUCT_RETROFIT_DYNAMIC_PARTITIONS)
    endif
  endif
endif

# 2. 设置了总开关 PRODUCT_USE_DYNAMIC_PARTITIONS = true, 则:
#    - 不能再设置 BOARD_BUILD_SYSTEM_ROOT_IMAGE = true,
#    - 必须设置 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
    ifeq ($(BOARD_BUILD_SYSTEM_ROOT_IMAGE),true)
        $(error BOARD_BUILD_SYSTEM_ROOT_IMAGE cannot be true for devices with dynamic partitions)
    endif
    ifneq ($(PRODUCT_USE_DYNAMIC_PARTITION_SIZE),true)
        $(error PRODUCT_USE_DYNAMIC_PARTITION_SIZE must be true for devices with dynamic partitions)
    endif
endif

# 3. 设置了 PRODUCT_BUILD_SUPER_PARTITION = true, 则:
#    - 必须设置 PRODUCT_USE_DYNAMIC_PARTITIONS = true
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)
    ifneq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)
        $(error Can only build super partition for devices with dynamic partitions)
    endif
endif

# 4. 设置了 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true 的前提下, 
#    分区列表(system, vendor, odm, product, product_service) 的大小参数:
#    BOARD_$(device)_PARTITION_SIZE 和 BOARD_$(device)_PARTITION_RESERVED_SIZE 只能设置一个
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITION_SIZE),true)

# 4.1 BOARD_SYSTEMIMAGE_PARTITION_SIZE 和 BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_SYSTEMIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_SYSTEMIMAGE_PARTITION_SIZE and \
    BOARD_SYSTEMIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.2 BOARD_VENDORIMAGE_PARTITION_SIZE 和 BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_VENDORIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_VENDORIMAGE_PARTITION_SIZE and \
    BOARD_VENDORIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.3 BOARD_ODMIMAGE_PARTITION_SIZE 和 BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_ODMIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_ODMIMAGE_PARTITION_SIZE and \
    BOARD_ODMIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.4 BOARD_PRODUCTIMAGE_PARTITION_SIZE 和 BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_PRODUCTIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_PRODUCTIMAGE_PARTITION_SIZE and \
    BOARD_PRODUCTIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

# 4.5 BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE 和 BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE 只能设置一个
ifneq ($(BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE),)
ifneq ($(BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE),)
$(error Should not define BOARD_PRODUCT_SERVICESIMAGE_PARTITION_SIZE and \
    BOARD_PRODUCT_SERVICESIMAGE_PARTITION_RESERVED_SIZE together)
endif
endif

endif # PRODUCT_USE_DYNAMIC_PARTITION_SIZE

# 5. 设置了 PRODUCT_USE_DYNAMIC_PARTITION_SIZE = true 的前提下, 
#    需要设置以下分组列表(google_dynamic_partitions) 的参数:
#    - BOARD_$(group)_PARTITION_LIST,
#    - BOARD_$(group)_SIZE, 
#    - BOARD_$(group)_PARTITION_PARTITION_LIST
ifeq ($(PRODUCT_USE_DYNAMIC_PARTITIONS),true)

# BOARD_SUPER_PARTITION_GROUPS defines a list of "updatable groups". Each updatable group is a
# group of partitions that share the same pool of free spaces.
# For each group in BOARD_SUPER_PARTITION_GROUPS, a BOARD_{GROUP}_SIZE and
# BOARD_{GROUP}_PARTITION_PARTITION_LIST may be defined.
#     - BOARD_{GROUP}_SIZE: The maximum sum of sizes of all partitions in the group.
#       Must not be empty.
#     - BOARD_{GROUP}_PARTITION_PARTITION_LIST: the list of partitions that belongs to this group.
#       If empty, no partitions belong to this group, and the sum of sizes is effectively 0.
# 5.1 如果没有设置过 BOARD_$(group)_PARTITION_LIST, 则默认为空，不包含任何分区
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(eval BOARD_$(group)_PARTITION_LIST ?=) \
    $(eval .KATI_READONLY := BOARD_$(group)_PARTITION_LIST) \
)
# 5.2 如果设置了 PRODUCT_BUILD_SUPER_PARTITION = true, 则设置:
#     BOARD_$(group)_SIZE, 例如: BOARD_SUPER_SIZE, 且不能为空。
#     实际上 PRODUCT_BUILD_SUPER_PARTITION 在 product_config.mk 会被设置为 PRODUCT_BUILD_SUPER_PARTITION 相同值
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(eval BOARD_$(group)_SIZE := $(strip $(BOARD_$(group)_SIZE))) \
    $(if $(BOARD_$(group)_SIZE),,$(error BOARD_$(group)_SIZE must not be empty)) \
    $(eval .KATI_READONLY := BOARD_$(group)_SIZE) \
)
endif # PRODUCT_BUILD_SUPER_PARTITION

# 6. BOARD_SUPER_PARTITION_GROUPS 不能设置为列表(system vendor product product_services odm)中的名字
# BOARD_*_PARTITION_LIST: a list of the following tokens
valid_super_partition_list := system vendor product product_services odm
$(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
    $(if $(filter-out $(valid_super_partition_list),$(BOARD_$(group)_PARTITION_LIST)), \
        $(error BOARD_$(group)_PARTITION_LIST contains invalid partition name \
            $(filter-out $(valid_super_partition_list),$(BOARD_$(group)_PARTITION_LIST)). \
            Valid names are $(valid_super_partition_list))))
valid_super_partition_list :=

# 7. 不能定义 BOARD_SUPER_PARTITION_PARTITION_LIST，该值通过计算获得
# Define BOARD_SUPER_PARTITION_PARTITION_LIST, the sum of all BOARD_*_PARTITION_LIST
ifdef BOARD_SUPER_PARTITION_PARTITION_LIST
$(error BOARD_SUPER_PARTITION_PARTITION_LIST should not be defined, but computed from \
    BOARD_SUPER_PARTITION_GROUPS and BOARD_*_PARTITION_LIST)
endif
BOARD_SUPER_PARTITION_PARTITION_LIST := \
    $(foreach group,$(call to-upper,$(BOARD_SUPER_PARTITION_GROUPS)), \
        $(BOARD_$(group)_PARTITION_LIST))
.KATI_READONLY := BOARD_SUPER_PARTITION_PARTITION_LIST

endif # PRODUCT_USE_DYNAMIC_PARTITIONS
```

#### 分区大小检查

```makefile

```

#### 总结





### 2.4 原生和改造动态分区的统一

```makefile
# build/make/core/config.mk
ifeq ($(PRODUCT_BUILD_SUPER_PARTITION),true)

#
# 1. 改造支持动态分区的情况
#    - 设置了 BOARD_SUPER_PARTITION_SIZE, 
#      如: BOARD_SUPER_PARTITION_SIZE := 4072669184
#    - 并且 PRODUCT_RETROFIT_DYNAMIC_PARTITIONS == true
ifneq ($(BOARD_SUPER_PARTITION_SIZE),)
ifeq ($(PRODUCT_RETROFIT_DYNAMIC_PARTITIONS),true)

# 1.1 必须设置 BOARD_SUPER_PARTITION_METADATA_DEVICE, 
#     如: BOARD_SUPER_PARTITION_METADATA_DEVICE := system
# The metadata device must be specified manually for retrofitting.
ifeq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),)
$(error Must specify BOARD_SUPER_PARTITION_METADATA_DEVICE if PRODUCT_RETROFIT_DYNAMIC_PARTITIONS=true.)
endif

# 1.2 必须设置 BOARD_SUPER_PARTITION_BLOCK_DEVICES
#     如: BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
# The super partition block device list must be specified manually for retrofitting.
ifeq ($(BOARD_SUPER_PARTITION_BLOCK_DEVICES),)
$(error Must specify BOARD_SUPER_PARTITION_BLOCK_DEVICES if PRODUCT_RETROFIT_DYNAMIC_PARTITIONS=true.)
endif

# 1.3 metadata 分区必须要包含在 super 分区的 block devices 列表中
# The metadata device must be included in the super partition block device list.
ifeq (,$(filter $(BOARD_SUPER_PARTITION_METADATA_DEVICE),$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)))
$(error BOARD_SUPER_PARTITION_METADATA_DEVICE is not listed in BOARD_SUPER_PARTITION_BLOCK_DEVICES.)
endif

# 1.4 metadata 分区必须传递给 kernel 的命令行启动参数: androidboot.super_partition
# The metadata device must be supplied to init via the kernel command-line.
INTERNAL_KERNEL_CMDLINE += androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)

# 1.5 生成 RETROFIT 相关的 OTA 包
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE := true

# If "vendor" is listed as one of the dynamic partitions but without its image available (e.g. an
# AOSP target built without vendor image), don't build the retrofit full OTA package. Because we
# won't be able to build meaningful super_* images for retrofitting purpose.
ifneq (,$(filter vendor,$(BOARD_SUPER_PARTITION_PARTITION_LIST)))
ifndef BUILDING_VENDOR_IMAGE
ifndef BOARD_PREBUILT_VENDORIMAGE
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=
endif # BOARD_PREBUILT_VENDORIMAGE
endif # BUILDING_VENDOR_IMAGE
endif # BOARD_SUPER_PARTITION_PARTITION_LIST

else # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
#
# 2. 原生动态分区的情况
#
# For normal devices, we populate BOARD_SUPER_PARTITION_BLOCK_DEVICES so the
# build can handle both cases consistently.

# 2.1 默认将 metadata device 设置为 super 分区
ifeq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),)
BOARD_SUPER_PARTITION_METADATA_DEVICE := super
endif

# 2.2 将 super 分区设置为 BOARD_SUPER_PARTITION_BLOCK_DEVICES
ifeq ($(BOARD_SUPER_PARTITION_BLOCK_DEVICES),)
BOARD_SUPER_PARTITION_BLOCK_DEVICES := $(BOARD_SUPER_PARTITION_METADATA_DEVICE)
endif

# 2.3 检查 block devices 分区数量, 如果只有一个 super 分区，则设置:
#     BOARD_SUPER_PARTITION_SUPER_DEVICE_SIZE ?= $(BOARD_SUPER_PARTITION_SIZE)
#     函数 $(word 2,$(list), 返回列表中变量 list 中的第 2 个 word, 如果没有，则为空。
# If only one super block device, default to super partition size.
ifeq ($(word 2,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)),)
BOARD_SUPER_PARTITION_$(call to-upper,$(strip $(BOARD_SUPER_PARTITION_BLOCK_DEVICES)))_DEVICE_SIZE ?= \
    $(BOARD_SUPER_PARTITION_SIZE)
endif

# 2.4 将 super 分区必须传递给 kernel 的命令行启动参数: androidboot.super_partition=super
ifneq ($(BOARD_SUPER_PARTITION_METADATA_DEVICE),super)
INTERNAL_KERNEL_CMDLINE += androidboot.super_partition=$(BOARD_SUPER_PARTITION_METADATA_DEVICE)
endif

# 2.5 不生成 RETROFIT 相关的 OTA 包
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=

endif # PRODUCT_RETROFIT_DYNAMIC_PARTITIONS
endif # BOARD_SUPER_PARTITION_SIZE
.KATI_READONLY := BOARD_SUPER_PARTITION_BLOCK_DEVICES
.KATI_READONLY := BOARD_SUPER_PARTITION_METADATA_DEVICE
.KATI_READONLY := BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE

#
# 3. 将 block devices 列表展开，检查列表中的每个分区是否已经设置了分区大小
#    如: BOARD_SUPER_PARTITION_BLOCK_DEVICES = system vendor product，则展开成 3 个变量:
#        BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE,
#        BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE,
#        BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE
$(foreach device,$(call to-upper,$(BOARD_SUPER_PARTITION_BLOCK_DEVICES)), \
    $(eval BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE := $(strip $(BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE))) \
    $(if $(BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE),, \
        $(error BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE must not be empty)) \
    $(eval .KATI_READONLY := BOARD_SUPER_PARTITION_$(device)_DEVICE_SIZE))

endif # PRODUCT_BUILD_SUPER_PARTITION
```

所以实际上动态分区最终需要以下这一组参数:



对于原生动态分区为:

```makefile
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := super
BOARD_SUPER_PARTITION_BLOCK_DEVICES := super
BOARD_SUPER_PARTITION_SUPER_DEVICE_SIZE := 4072669184
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE :=
```

对于改造动态分区为:

```makefile
BOARD_SUPER_PARTITION_SIZE := 4072669184
BOARD_SUPER_PARTITION_METADATA_DEVICE := system
BOARD_SUPER_PARTITION_BLOCK_DEVICES := system vendor product
BOARD_SUPER_PARTITION_SYSTEM_DEVICE_SIZE := 2952790016
BOARD_SUPER_PARTITION_VENDOR_DEVICE_SIZE := 805306368
BOARD_SUPER_PARTITION_PRODUCT_DEVICE_SIZE := 314572800
BOARD_GOOGLE_DYNAMIC_PARTITIONS_SIZE := 4069523456
BOARD_BUILD_RETROFIT_DYNAMIC_PARTITIONS_OTA_PACKAGE := true
```

### 

