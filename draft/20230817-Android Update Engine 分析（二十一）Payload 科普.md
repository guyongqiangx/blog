# 20230817-Android Update Engine 分析（二十一）Payload 科普



## Update Payload Generation

The update payload generation is the process of converting a set of partitions/files into a format that is both understandable by the updater client (especially if it's a much older version) and is securely verifiable. This process involves breaking the input partitions into smaller components and compressing them in order to help with network bandwidth when downloading the payloads.

`delta_generator` is a tool with a wide range of options for generating different types of update payloads. Its code is located in `update_engine/payload_generator`. This directory contains all the source code related to mechanics of generating an update payload. None of the files in this directory should be included or used in any other library/executable other than the `delta_generator` which means this directory does not get compiled into the rest of the update engine tools.

However, it is not recommended to use `delta_generator` directly, as it has way too many flags. Wrappers like [ota*from*target_files](https://cs.android.com/android/platform/superproject/+/master:build/make/tools/releasetools/ota_from_target_files.py) or [OTA Generator](https://github.com/google/ota-generator) should be used.

### Update Payload File Specification

Each update payload file has a specific structure defined in the table below:

| Field                   | Size (bytes) | Type                                                         | Description                                                  |
| ----------------------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Magic Number            | 4            | char[4]                                                      | Magic string "CrAU" identifying this is an update payload.   |
| Major Version           | 8            | uint64                                                       | Payload major version number.                                |
| Manifest Size           | 8            | uint64                                                       | Manifest size in bytes.                                      |
| Manifest Signature Size | 4            | uint32                                                       | Manifest signature blob size in bytes (only in major version 2). |
| Manifest                | Varies       | [DeltaArchiveManifest](http://aospxref.com/update_metadata.proto#302) | The list of operations to be performed.                      |
| Manifest Signature      | Varies       | [Signatures](http://aospxref.com/update_metadata.proto#122)  | The signature of the first five fields. There could be multiple signatures if the key has changed. |
| Payload Data            | Varies       | List of raw or compressed data blobs                         | The list of binary blobs used by operations in the metadata. |
| Payload Signature Size  | Varies       | uint64                                                       | The size of the payload signature.                           |
| Payload Signature       | Varies       | [Signatures](http://aospxref.com/update_metadata.proto#122)  | The signature of the entire payload except the metadata signature. There could be multiple signatures if the key has changed. |

### Delta vs. Full Update Payloads

There are two types of payload: Full and Delta. A full payload is generated solely from the target image (the image we want to update to) and has all the data necessary to update the inactive partition. Hence, full payloads can be quite large in size. A delta payload, on the other hand, is a differential update generated by comparing the source image (the active partitions) and the target image and producing the diffs between these two images. It is basically a differential update similar to applications like `diff` or `bsdiff`. Hence, updating the system using the delta payloads requires the system to read parts of the active partition in order to update the inactive partition (or reconstruct the target partition). The delta payloads are significantly smaller than the full payloads. The structure of the payload is equal for both types.

Payload generation is quite resource intensive and its tools are implemented with high parallelism.

#### Generating Full Payloads

A full payload is generated by breaking the partition into 2MiB (configurable) chunks and either compressing them using bzip2 or XZ algorithms or keeping it as raw data depending on which produces smaller data. Full payloads are much larger in comparison to delta payloads hence require longer download time if the network bandwidth is limited. On the other hand, full payloads are a bit faster to apply because the system doesn’t need to read data from the source partition.

#### Generating Delta Payloads

Delta payloads are generated by looking at both the source and target images data on a file and metadata basis (more precisely, the file system level on each appropriate partition). The reason we can generate delta payloads is that Chrome OS partitions are read only. So with high certainty we can assume the active partitions on the client’s device is bit-by-bit equal to the original partitions generated in the image generation/signing phase. The process for generating a delta payload is roughly as follows:

1. Find all the zero-filled blocks on the target partition and produce `ZERO` operation for them. `ZERO` operation basically discards the associated blocks (depending on the implementation).
2. Find all the blocks that have not changed between the source and target partitions by directly comparing one-to-one source and target blocks and produce `SOURCE_COPY` operation.
3. List all the files (and their associated blocks) in the source and target partitions and remove blocks (and files) which we have already generated operations for in the last two steps. Assign the remaining metadata (inodes, etc) of each partition as a file.
4. If a file is new, generate a `REPLACE`, `REPLACE_XZ`, or `REPLACE_BZ` operation for its data blocks depending on which one generates a smaller data blob.
5. For each other file, compare the source and target blocks and produce a `SOURCE_BSDIFF` or `PUFFDIFF` operation depending on which one generates a smaller data blob. These two operations produce binary diffs between a source and target data blob. (Look at [bsdiff](https://android.googlesource.com/platform/external/bsdiff/+/master) and [puffin](https://android.googlesource.com/platform/external/puffin/+/master) for details of such binary differential programs!)
6. Sort the operations based on their target partitions’ block offset.
7. Optionally merge same or similar operations next to each other into larger operations for better efficiency and potentially smaller payloads.

Full payloads can only contain `REPLACE`, `REPLACE_BZ`, and `REPLACE_XZ` operations. Delta payloads can contain any operations.

### Major and Minor versions

The major and minor versions specify the update payload file format and the capability of the updater client to accept certain types of update payloads respectively. These numbers are [hard coded](http://aospxref.com/update_engine.conf) in the updater client.

Major version is basically the update payload file version specified in the [update payload file specification](http://aospxref.com/android-13.0.0_r3/xref/system/update_engine/#update-payload-file-specification) above (second field). Each updater client supports a range of major versions. Currently, there are only two major versions: 1, and 2. And both Chrome OS and Android are on major version 2 (major version 1 is being deprecated). Whenever there are new additions that cannot be fitted in the [Manifest protobuf](http://aospxref.com/update_metadata.proto), we need to uprev the major version. Upreving major version should be done with utmost care because older clients do not know how to handle the newer versions. Any major version uprev in Chrome OS should be associated with a GoldenEye stepping stone.

Minor version defines the capability of the updater client to accept certain operations or perform certain actions. Each updater client supports a range of minor versions. For example, the updater client with minor version 4 (or less) does not know how to handle a `PUFFDIFF` operation. So when generating a delta payload for an image which has an updater client with minor version 4 (or less) we cannot produce PUFFDIFF operation for it. The payload generation process looks at the source image’s minor version to decide the type of operations it supports and only a payload that confirms to those restrictions. Similarly, if there is a bug in a client with a specific minor version, an uprev in the minor version helps with avoiding to generate payloads that cause that bug to manifest. However, upreving minor versions is quite expensive too in terms of maintainability and it can be error prone. So one should practice caution when making such a change.

Minor versions are irrelevant in full payloads. Full payloads should always be able to be applied for very old clients. The reason is that the updater clients may not send their current version, so if we had different types of full payloads, we would not have known which version to serve to the client.

### Signed vs Unsigned Payloads

Update payloads can be signed (with private/public key pairs) for use in production or be kept unsigned for use in testing. Tools like `delta_generator` help with generating metadata and payload hashes or signing the payloads given private keys.

