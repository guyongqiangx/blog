# Android 动态分区详解(四)

动态分区机制的底层由 linux 的 device mapper 驱动实现。因此，Android 的动态分区，主要强调的是 linux 驱动之上，Android 对动态分区的管理。第一篇中提到过我对 Android 动态分区本质的看法: 动态分区管理的本质就是对分区数据的增删改查操作，操作的对象就是动态分区描述数据 metadata。

而对于 OTA 升级，其本质就是围绕升级数据 payload 文件的一些列操作，包括：

- 增，即 payload 文件的生成

- 删，无需此操作

- 改，各种对 payload 文件的修改，包括生成过程中的调整操作，对 payload 的修改签名等

- 查，在接收到 payload 数据后对 payload 数据解包，解析 manifest，遍历各种操作

- 传输，升级时客户端和服务端对 payload 数据的收发

动态分区数据，属于 payload 数据的一部分，自然而然就需要专注如何将动态分区数据打包到 payload 中，客户端接收到 payload 数据后如何解析除动态分区数据，然后又是如何使用这些动态分区数据进行更新的。本文会一一对这些疑问进行解惑。

## 1. 动态分区的 manifest

在开始介绍前，先看下动态分区数据再 payload 中是如何存储的。

##2. 生成 payload.bin

### 1. 修改代码

#### 1. 基线代码

为了验证这个问题，我先编译基线包:

```makefile
# 默认分区配置(old)
# 
BOARD_SUPER_PARTITION_SIZE         := 3028287488 # 2888M
BOARD_BCM_REF_SIZE                 := 1509949440 # (SUPER/2)-4MB
```

然后执行编译:

```bash
make PRODUCT-inuvik-userdebug dist DIST_DIR=dist_old -j128
```

#### 2. 调整分组大小

修改分区，调整 `bcm_ref` 分组大小:

```makefile
# 新分区配置(new)
BOARD_SUPER_PARTITION_SIZE         := 3028287488 # 2888M
BOARD_BCM_REF_SIZE                 := 1510998016 # (SUPER - 4M - 2M)/2
```

然后执行编译:

```bash
make PRODUCT-inuvik-userdebug dist DIST_DIR=dist_new -j128
```

### 2. 生成差分包

对上一节 `dist_old` 和 `dist_new` 目录下的 target 包制作差分升级包:

```bash
$ ./build/tools/releasetools/ota_from_target_files.py -v \
  -i dist_old/inuvik-target_files-eng.rg935739.zip \
  dist_new/inuvik-target_files-eng.rg935739.zip update-20220411.zip
```

检查差分 log，找到调动 `delta_generator` 生成 payload.bin 的命令:

> 为了方便查看，这里我将原来的临时文件的名字进行了修改，比如:
>
> - 新分区对应的 image, 将临时文件名替换为 new: `/tmp/boot.img.ClrNfM` 替换为 `/tmp/boot.img.new`
>
> - 旧分区对应的 image, 将临时文件名替换为 new: `/tmp/boot.img.uQrHoV` 替换为 `/tmp/boot.img.old`

```shell
out/host/linux-x86/bin/delta_generator \
	--out_file=/tmp/payload-SFUNWb.bin \
	--partition_names=boot:system:vendor:dtbo:vbmeta \
	--new_partitions=/tmp/boot.img.ClrNfM:/tmp/system.img.cMfuYe:/tmp/vendor.img.S7u28f:/tmp/dtbo.img.OW4LIL:/tmp/vbmeta.img.h9ag4M \
	--new_mapfiles=:/tmp/system.map.vqHu7I:/tmp/vendor.map.tKCdwU:: \
	--old_partitions=/tmp/boot.img.uQrHoV:/tmp/system.img.FZleEq:/tmp/vendor.img.Nd5gQw:/tmp/dtbo.img.RK0nZV:/tmp/vbmeta.img.NP7TND \
	--old_mapfiles=:/tmp/system.map.cicgCG:/tmp/vendor.map.ymrOh0:: \
	--minor_version=6 \
	--major_version=2 \
	--max_timestamp=1649646814 \
	--dynamic_partition_info_file=/tmp/dynamic_partitions_info.zH7uRw
```

这里多了一个参数 `--dynamic_partition_info_file=/tmp/dynamic_partitions_info.zH7uRw`

那么这个参数是如何来的呢？

在 `cmd_generate()`函数中，我们可以看到是通过 `DYNAMIC_PARTITION_INFO_FILE` 变量设置 `dynamic_partition_info_file` 参数的。

```bash
cmd_generate() {
  # ...

  if [[ -n "{DYNAMIC_PARTITION_INFO_FILE}" ]]; then
    GENERATOR_ARGS+=(
      --dynamic_partition_info_file="${DYNAMIC_PARTITION_INFO_FILE}"
    )
  fi

  echo "Running delta_generator with args: ${GENERATOR_ARGS[@]}"
  echo "${GENERATOR} ${GENERATOR_ARGS[@]}"
  "${GENERATOR}" "${GENERATOR_ARGS[@]}"

  echo "Done generating ${payload_type} update."
}
```

再往前追溯一步，变量 `DYNAMIC_PARTITION_INFO_FILE` 又是在哪里设置的呢？通过搜索可以看到，在 `extract_image_brillo()` 函数中，提取 target image 中的 `META/dynamic_partitions_info.txt` 文件到一个临时文件，并将其路径赋值给 `DYNAMIC_PARTITION_INFO_FILE`

```bash
# extract_image_brillo <target_files.zip> <partitions_array> [partitions_order]
#
# Extract the A/B updated partitions from a Brillo target_files zip file into
# new temporary files.
extract_image_brillo() {
  local image="$1"
  local partitions_array="$2"
  local partitions_order="${3:-}"

  # ...

  if [[ "${partitions_array}" == "SRC_PARTITIONS" ]]; then
    # Source image
    # ...
  else
    # Target image
    # ...
    local dynamic_partitions_info=$(create_tempfile "dynamic_partitions_info.XXXXXX")
    CLEANUP_FILES+=("${dynamic_partitions_info}")
    if unzip -p "${image}" "META/dynamic_partitions_info.txt" \
        >"${dynamic_partitions_info}"; then
      DYNAMIC_PARTITION_INFO_FILE="${dynamic_partitions_info}"
    fi
  fi

  # ...
}
```

所以我们看下 target file 中的 `META/dynamic_partitions_info.txt` 文件长什么样？

```bash
$ unzip -p dist_new/inuvik-target_files-eng.rg935739.zip META/dynamic_partitions_info.txt
super_partition_groups=bcm_ref
bcm_ref_size=1510998016
bcm_ref_partition_list=system vendor
```

这个 target file 中的 `META/dynamic_partitions_info.txt` 文件时什么时候生成的呢？

在编译 super.img 会有对 `BUILT_TARGET_FILES_PACKAGE` 目标的依赖，在处理 `BUILT_TARGET_FILES_PACKAGE` 目标时，会将动态分区相关信息输出到 `$(zip_root)/META/dynamic_partitions_info.txt` 文件中。



然后接下来就追踪 `delta_generator` 是如何处理 `--dynamic_partition_info_file` 参数的？

```bash
$ grep -Rn dynamic_partition_info_file system/update_engine/
system/update_engine/payload_generator/generate_delta_main.cc:420:  DEFINE_string(dynamic_partition_info_file,
system/update_engine/payload_generator/generate_delta_main.cc:577:  if (!FLAGS_dynamic_partition_info_file.empty()) {
system/update_engine/payload_generator/generate_delta_main.cc:582:    CHECK(store.Load(base::FilePath(FLAGS_dynamic_partition_info_file)));
system/update_engine/scripts/brillo_update_payload:657:      --dynamic_partition_info_file="${DYNAMIC_PARTITION_INFO_FILE}"
```

读取动态分区文件的内容，并加载到 `payload_config.target` 结构中:
```c++
# system/update_engine/payload_generator/generate_delta_main.cc
if (!FLAGS_dynamic_partition_info_file.empty()) {
    LOG_IF(FATAL, FLAGS_major_version == kChromeOSMajorPayloadVersion)
        << "Dynamic partition info is only allowed in major version 2 or "
           "newer.";
    brillo::KeyValueStore store;
    CHECK(store.Load(base::FilePath(FLAGS_dynamic_partition_info_file)));
    CHECK(payload_config.target.LoadDynamicPartitionMetadata(store));
    CHECK(payload_config.target.ValidateDynamicPartitionMetadata());
  }
```



```c++
/* system/update_engine/payload_generator/payload_generation_config.cc */
bool ImageConfig::LoadDynamicPartitionMetadata(
    const brillo::KeyValueStore& store) {
  auto metadata = std::make_unique<DynamicPartitionMetadata>();
  string buf;
  if (!store.GetString("super_partition_groups", &buf)) {
    LOG(ERROR) << "Dynamic partition info missing super_partition_groups.";
    return false;
  }
  # 使用空格分割 super_partition_groups 字符串，这里只有一个 bcm_ref
  auto group_names = brillo::string_utils::Split(buf, " ");
  for (const auto& group_name : group_names) {
    DynamicPartitionGroup* group = metadata->add_groups();
    group->set_name(group_name);
    # 获取 bcm_ref_size 键值对的内容: bcm_ref_size=1510998016
    if (!store.GetString(group_name + "_size", &buf)) {
      LOG(ERROR) << "Missing " << group_name + "_size.";
      return false;
    }

    # 将 bcm_ref_size 的值转换成整数
    uint64_t max_size;
    if (!base::StringToUint64(buf, &max_size)) {
      LOG(ERROR) << group_name << "_size=" << buf << " is not an integer.";
      return false;
    }
    # 设置分区组的大小 group("bcm_ref").size = 1510998016
    group->set_size(max_size);

    # 设置分区组包含的分区: bcm_ref_partition_list=system vendor
    if (store.GetString(group_name + "_partition_list", &buf)) {
      auto partition_names = brillo::string_utils::Split(buf, " ");
      for (const auto& partition_name : partition_names) {
        group->add_partition_names()->assign(partition_name);
      }
    }
  }
  
  # 将动态分区文件解析的结果设置到 dynamic_partition_metadata 中
  dynamic_partition_metadata = std::move(metadata);
  return true;
}

bool ImageConfig::ValidateDynamicPartitionMetadata() const {
  if (dynamic_partition_metadata == nullptr) {
    LOG(ERROR) << "dynamic_partition_metadata is not loaded.";
    return false;
  }

  for (const auto& group : dynamic_partition_metadata->groups()) {
    uint64_t sum_size = 0;
    for (const auto& partition_name : group.partition_names()) {
      auto partition_config = std::find_if(partitions.begin(),
                                           partitions.end(),
                                           [&partition_name](const auto& e) {
                                             return e.name == partition_name;
                                           });

      if (partition_config == partitions.end()) {
        LOG(ERROR) << "Cannot find partition " << partition_name
                   << " which is in " << group.name() << "_partition_list";
        return false;
      }
      sum_size += partition_config->size;
    }

    if (sum_size > group.size()) {
      LOG(ERROR) << "Sum of sizes in " << group.name() << "_partition_list is "
                 << sum_size << ", which is greater than " << group.name()
                 << "_size (" << group.size() << ")";
      return false;
    }
  }
  return true;
}
```



在 `PayloadFile::Init()` 中，将 `dynamic_partition_metadata` 设置到 `manifest_` 中。

如果想看下 `dynamic_partition_metadata` 到底都有哪些地方引用，可以使出万能的 grep 大法:

```bash
$ grep -Rn dynamic_partition_metadata system/update_engine/ --exclude="*unittest.cc"
```



在代码中:

```c++
/* system/update_engine/payload_generator/payload_file.cc */
bool PayloadFile::Init(const PayloadGenerationConfig& config) {
  // ...

  if (major_version_ == kBrilloMajorPayloadVersion) {
    if (config.target.dynamic_partition_metadata != nullptr)
      *(manifest_.mutable_dynamic_partition_metadata()) =
          *(config.target.dynamic_partition_metadata);
  }

  return true;
}
```



然后在 `PaylodFile::WritePayload()` 函数中将 `manifest_` 序列化，转换成二进制数据。

```c++
/* system/update_engine/payload_generator/payload_file.cc */
bool PayloadFile::WritePayload(const string& payload_file,
                               const string& data_blobs_path,
                               const string& private_key_path,
                               uint64_t* metadata_size_out) {
  // ...

  // Serialize protobuf
  string serialized_manifest;
  TEST_AND_RETURN_FALSE(manifest_.SerializeToString(&serialized_manifest));

  // ...
  return true;
}
```

## 3. 使用 payload.bin

#### DeltaPerformer::ParseManifestPartitions

```c++
/* system/update_engine/payload_consumer/delta_performer.cc */
bool DeltaPerformer::ParseManifestPartitions(ErrorCode* error) {
	// ...
  
  // 
  if (install_plan_->target_slot != BootControlInterface::kInvalidSlot) {
    if (!InitPartitionMetadata()) {
      *error = ErrorCode::kInstallDeviceOpenError;
      return false;
    }
  }

  if (!install_plan_->LoadPartitionsFromSlots(boot_control_)) {
    LOG(ERROR) << "Unable to determine all the partition devices.";
    *error = ErrorCode::kInstallDeviceOpenError;
    return false;
  }
  LogPartitionInfo(partitions_);
  return true;
}
```

#### DeltaPerformer::Write

```c++
/* system/update_engine/payload_consumer/delta_performer.cc */
bool DeltaPerformer::Write(const void* bytes, size_t count, ErrorCode* error) {
  // ...

  // This populates |partitions_| and the |install_plan.partitions| with the
  // list of partitions from the manifest.
  if (!ParseManifestPartitions(error))
    return false;

  // ...

  return true;
}
```



#### DeltaPerformer::InitPartitionMetadata

```c++
/* system/update_engine/payload_consumer/delta_performer.cc */
bool DeltaPerformer::InitPartitionMetadata() {
  BootControlInterface::PartitionMetadata partition_metadata;
  /* 如果 manifest_ 包含 dynamic_partition_metadata */
  if (manifest_.has_dynamic_partition_metadata()) {
    std::map<string, uint64_t> partition_sizes;
    for (const auto& partition : install_plan_->partitions) {
      partition_sizes.emplace(partition.name, partition.target_size);
    }
    /* 遍历 menifest_ 中的 dynamic_partition_metadata 数据的 groups */
    for (const auto& group : manifest_.dynamic_partition_metadata().groups()) {
      BootControlInterface::PartitionMetadata::Group e;
      e.name = group.name();
      e.size = group.size();
      for (const auto& partition_name : group.partition_names()) {
        auto it = partition_sizes.find(partition_name);
        if (it == partition_sizes.end()) {
          // TODO(tbao): Support auto-filling partition info for framework-only
          // OTA.
          LOG(ERROR) << "dynamic_partition_metadata contains partition "
                     << partition_name
                     << " but it is not part of the manifest. "
                     << "This is not supported.";
          return false;
        }
        e.partitions.push_back({partition_name, it->second});
      }
      /* 将解析 manifest_ 得到的 groups 和 partitions 存放到 partition_metadata 中 */
      partition_metadata.groups.push_back(std::move(e));
    }
  }

  bool metadata_updated = false;
  prefs_->GetBoolean(kPrefsDynamicPartitionMetadataUpdated, &metadata_updated);
  /* 通过 boot_control_->InitPartitionMetadata 调用更新槽位对应的 metadata */
  if (!boot_control_->InitPartitionMetadata(
          install_plan_->target_slot, partition_metadata, !metadata_updated)) {
    LOG(ERROR) << "Unable to initialize partition metadata for slot "
               << BootControlInterface::SlotName(install_plan_->target_slot);
    return false;
  }
  TEST_AND_RETURN_FALSE(
      prefs_->SetBoolean(kPrefsDynamicPartitionMetadataUpdated, true));
  LOG(INFO) << "InitPartitionMetadata done.";

  return true;
}
```



#### BootControlAndroid::InitPartitionMetadata

```c++
/* system/update_engine/boot_control_android.cc */
bool BootControlAndroid::InitPartitionMetadata(
    Slot target_slot,
    const PartitionMetadata& partition_metadata,
    bool update_metadata) {
  if (fs_mgr_overlayfs_is_setup()) {
    // Non DAP devices can use overlayfs as well.
    LOG(WARNING)
        << "overlayfs overrides are active and can interfere with our "
           "resources.\n"
        << "run adb enable-verity to deactivate if required and try again.";
  }
  /* 检查属性 "ro.boot.dynamic_partitions", 判断是否打开了动态分区
   * console:/ # getprop | grep dynamic
   * [ro.boot.dynamic_partitions]: [true]
   */
  if (!dynamic_control_->IsDynamicPartitionsEnabled()) {
    return true;
  }

  /* 将当前槽位作为 source_slot */
  auto source_slot = GetCurrentSlot();
  if (target_slot == source_slot) {
    LOG(ERROR) << "Cannot call InitPartitionMetadata on current slot.";
    return false;
  }

  // Although the current build supports dynamic partitions, the given payload
  // doesn't use it for target partitions. This could happen when applying a
  // retrofit update. Skip updating the partition metadata for the target slot.
  is_target_dynamic_ = !partition_metadata.groups.empty();
  if (!is_target_dynamic_) {
    return true;
  }

  if (!update_metadata) {
    return true;
  }

  // 获取目标槽位的后缀名称 target_suffix
  string target_suffix;
  if (!GetSuffix(target_slot, &target_suffix)) {
    return false;
  }

  // 通过函数见名知意，这里取消目标槽位所有分区的映射
  // Unmap all the target dynamic partitions because they would become
  // inconsistent with the new metadata.
  if (!UnmapTargetPartitions(
          dynamic_control_.get(), target_suffix, partition_metadata)) {
    return false;
  }

  // 更新目标槽位分区组对应的 metadata
  return UpdatePartitionMetadata(dynamic_control_.get(),
                                 source_slot,
                                 target_slot,
                                 target_suffix,
                                 partition_metadata);
}
```



#### UpdatePartitionMetadata

```c++
/* system/update_engine/boot_control_android.cc */
bool UpdatePartitionMetadata(DynamicPartitionControlInterface* dynamic_control,
                             Slot source_slot,
                             Slot target_slot,
                             const string& target_suffix,
                             const PartitionMetadata& partition_metadata) {
  // 获取 misc 分区对应的路径: /dev/block/platform/soc.0/7824900.sdhci/by-name/misc
  string device_dir_str;
  if (!dynamic_control->GetDeviceDir(&device_dir_str)) {
    return false;
  }
  // 获取 super 设备的路径，待进一步追查
  base::FilePath device_dir(device_dir_str);
  auto source_device =
      device_dir.Append(fs_mgr_get_super_partition_name(source_slot)).value();

  // 从 super 设备读取指定 source_slot 的 metadata 并返回
  auto builder = dynamic_control->LoadMetadataBuilder(
      source_device, source_slot, target_slot);
  if (builder == nullptr) {
    // TODO(elsk): allow reconstructing metadata from partition_metadata
    // in recovery sideload.
    LOG(ERROR) << "No metadata at "
               << BootControlInterface::SlotName(source_slot);
    return false;
  }

  // 遍历现有 metadata 的 group，并移除每一个 group 及其包含的分区
  std::vector<string> groups = builder->ListGroups();
  for (const auto& group_name : groups) {
    if (base::EndsWith(
            group_name, target_suffix, base::CompareCase::SENSITIVE)) {
      LOG(INFO) << "Removing group " << group_name;
      builder->RemoveGroupAndPartitions(group_name);
    }
  }

  // 计算所有新分区组 partition_metadata 的大小
  uint64_t total_size = 0;
  for (const auto& group : partition_metadata.groups) {
    total_size += group.size;
  }

  // 检查新分组所有分区大小是否满足条件 total_size <= allocatable_space/2
  // 对于 allocatable_space, 主要是 super 分区除去前面 metadata 部分剩余空间 / 2
  string expr;
  uint64_t allocatable_space = builder->AllocatableSpace();
  if (!dynamic_control->IsDynamicPartitionsRetrofit()) {
    allocatable_space /= 2;
    expr = "half of ";
  }
  if (total_size > allocatable_space) {
    LOG(ERROR) << "The maximum size of all groups with suffix " << target_suffix
               << " (" << total_size << ") has exceeded " << expr
               << " allocatable space for dynamic partitions "
               << allocatable_space << ".";
    return false;
  }

  // 遍历新分区的分组，将其添加到 builder 对象中(前面已经清空 builder 内部保存的所有分组)
  for (const auto& group : partition_metadata.groups) {
    auto group_name_suffix = group.name + target_suffix;
    if (!builder->AddGroup(group_name_suffix, group.size)) {
      LOG(ERROR) << "Cannot add group " << group_name_suffix << " with size "
                 << group.size;
      return false;
    }
    LOG(INFO) << "Added group " << group_name_suffix << " with size "
              << group.size;

    // 遍历每一个分组内的分区, 设置分区名为 partition.name + target_suffix 的格式
    for (const auto& partition : group.partitions) {
      auto partition_name_suffix = partition.name + target_suffix;
      Partition* p = builder->AddPartition(
          partition_name_suffix, group_name_suffix, LP_PARTITION_ATTR_READONLY);
      if (!p) {
        LOG(ERROR) << "Cannot add partition " << partition_name_suffix
                   << " to group " << group_name_suffix;
        return false;
      }
      // 设置分区大小
      if (!builder->ResizePartition(p, partition.size)) {
        LOG(ERROR) << "Cannot resize partition " << partition_name_suffix
                   << " to size " << partition.size << ". Not enough space?";
        return false;
      }
      LOG(INFO) << "Added partition " << partition_name_suffix << " to group "
                << group_name_suffix << " with size " << partition.size;
    }
  }

  // 获取 tareget_slot 的 super 对应的设备名称
  auto target_device =
      device_dir.Append(fs_mgr_get_super_partition_name(target_slot)).value();
  // 将添加了新分组和新分区的 metadata 保存到设备上
  return dynamic_control->StoreMetadata(
      target_device, builder.get(), target_slot);
}
```



#### DynamicPartitionControlAndroid::LoadMetadataBuilder

```c++
/* system/update_engine/dynamic_partition_control_android.cc */
std::unique_ptr<MetadataBuilder>
DynamicPartitionControlAndroid::LoadMetadataBuilder(
    const std::string& super_device,
    uint32_t source_slot,
    uint32_t target_slot) {
  std::unique_ptr<MetadataBuilder> builder;

  // 如果槽位无效，或者是改造动态分区，则调用 MetadataBuilder::NewForUpdate() 生成动态分区 metadata
  if (target_slot != BootControlInterface::kInvalidSlot &&
      IsDynamicPartitionsRetrofit()) {
    builder = MetadataBuilder::NewForUpdate(
        PartitionOpener(), super_device, source_slot, target_slot);
  }
  // 对于原生动态分区 OTA 的情况，调用 MetadataBuilder::New() 加载动态分区 metadata
  else 
  {
    builder =
        MetadataBuilder::New(PartitionOpener(), super_device, source_slot);
  }

  if (builder == nullptr) {
    LOG(WARNING) << "No metadata slot "
                 << BootControlInterface::SlotName(source_slot) << " in "
                 << super_device;
    return nullptr;
  }
  LOG(INFO) << "Loaded metadata from slot "
            << BootControlInterface::SlotName(source_slot) << " in "
            << super_device;
  return builder;
}
```



####  DynamicPartitionControlAndroid::StoreMetadata

```c++
/* system/update_engine/dynamic_partition_control_android.cc */
bool DynamicPartitionControlAndroid::StoreMetadata(
    const std::string& super_device,
    MetadataBuilder* builder,
    uint32_t target_slot) {
  auto metadata = builder->Export();
  if (metadata == nullptr) {
    LOG(ERROR) << "Cannot export metadata to slot "
               << BootControlInterface::SlotName(target_slot) << " in "
               << super_device;
    return false;
  }

  // 如果是改造动态分区的情况，调用 FlashPartitionTable 写入 metadata
  if (IsDynamicPartitionsRetrofit()) {
    if (!FlashPartitionTable(super_device, *metadata)) {
      LOG(ERROR) << "Cannot write metadata to " << super_device;
      return false;
    }
    LOG(INFO) << "Written metadata to " << super_device;
  }
  // 原生动态分区的情况，调用 UpdatePartitionTable 更新 target_slot 对应的 metadata
  else 
  {
    if (!UpdatePartitionTable(super_device, *metadata, target_slot)) {
      LOG(ERROR) << "Cannot write metadata to slot "
                 << BootControlInterface::SlotName(target_slot) << " in "
                 << super_device;
      return false;
    }
    LOG(INFO) << "Copied metadata to slot "
              << BootControlInterface::SlotName(target_slot) << " in "
              << super_device;
  }

  return true;
}
```



#### InstallPlan::LoadPartitionsFromSlots

```c++
bool InstallPlan::LoadPartitionsFromSlots(BootControlInterface* boot_control) {
  bool result = true;
  // 遍历所有分区，并在底层调用 device mapper 逐个映射分区 source 和 target 分区
  // 映射结果路径存放到 partition.source_path 和 partition.target_path 中
  for (Partition& partition : partitions) {
    if (source_slot != BootControlInterface::kInvalidSlot &&
        partition.source_size > 0) {
      result = boot_control->GetPartitionDevice(
                   partition.name, source_slot, &partition.source_path) &&
               result;
    } else {
      partition.source_path.clear();
    }

    if (target_slot != BootControlInterface::kInvalidSlot &&
        partition.target_size > 0) {
      result = boot_control->GetPartitionDevice(
                   partition.name, target_slot, &partition.target_path) &&
               result;
    } else {
      partition.target_path.clear();
    }
  }
  return result;
}
```

#### BootControlAndroid::GetPartitionDevice

```c++
/* system/update_engine/boot_control_android.cc */
bool BootControlAndroid::GetPartitionDevice(const string& partition_name,
                                            Slot slot,
                                            string* device) const {
  string suffix;
  if (!GetSuffix(slot, &suffix)) {
    return false;
  }
  const string partition_name_suffix = partition_name + suffix;

  string device_dir_str;
  if (!dynamic_control_->GetDeviceDir(&device_dir_str)) {
    return false;
  }
  base::FilePath device_dir(device_dir_str);

  // When looking up target partition devices, treat them as static if the
  // current payload doesn't encode them as dynamic partitions. This may happen
  // when applying a retrofit update on top of a dynamic-partitions-enabled
  // build.
  if (dynamic_control_->IsDynamicPartitionsEnabled() &&
      (slot == GetCurrentSlot() || is_target_dynamic_)) {
    switch (GetDynamicPartitionDevice(
        device_dir, partition_name_suffix, slot, device)) {
      case DynamicPartitionDeviceStatus::SUCCESS:
        return true;
      case DynamicPartitionDeviceStatus::TRY_STATIC:
        break;
      case DynamicPartitionDeviceStatus::ERROR:  // fallthrough
      default:
        return false;
    }
  }

  base::FilePath path = device_dir.Append(partition_name_suffix);
  if (!dynamic_control_->DeviceExists(path.value())) {
    LOG(ERROR) << "Device file " << path.value() << " does not exist.";
    return false;
  }

  *device = path.value();
  return true;
}
```

此时分区的 metadata 已经更新，并且重新映射好了，对后面的使用者来说，只需要关注已经映射好的设备，并对这些映射好的设备进行差分更新操作就可以了。

## 4. 总结

在调用脚本工具 `ota_from_target_files.py` 生成动态分区对应的 OTA 包时:

```bash
$ ./build/tools/releasetools/ota_from_target_files.py -v \
  -i dist_old/inuvik-target_files-eng.rg935739.zip \
  dist_new/inuvik-target_files-eng.rg935739.zip update-20220411.zip
```

Python 脚本主要是解析命令行参数，根据当前生成 OTA 包的类型(是否 A/B 系统的 OTA 包，是全量包还是增量包等), 然后进一步调用 Shell 脚本 `brillo_update_payload`，将 target files 包中的各种 image 提取出来存放到临时文件中，如果是 sparse image 格式的，需要将其转换成  raw image 格式(比如 system 和 vendor 分区)。

然后进一步调用 `delta_generator` 生成 payload.bin，详细的调用命令如下(这里以差分包为例):

```bash
out/host/linux-x86/bin/delta_generator \
	--out_file=/tmp/payload-SFUNWb.bin \
	--partition_names=boot:system:vendor:dtbo:vbmeta \
	--new_partitions=/tmp/boot.img.ClrNfM:/tmp/system.img.cMfuYe:/tmp/vendor.img.S7u28f:/tmp/dtbo.img.OW4LIL:/tmp/vbmeta.img.h9ag4M \
	--new_mapfiles=:/tmp/system.map.vqHu7I:/tmp/vendor.map.tKCdwU:: \
	--old_partitions=/tmp/boot.img.uQrHoV:/tmp/system.img.FZleEq:/tmp/vendor.img.Nd5gQw:/tmp/dtbo.img.RK0nZV:/tmp/vbmeta.img.NP7TND \
	--old_mapfiles=:/tmp/system.map.cicgCG:/tmp/vendor.map.ymrOh0:: \
	--minor_version=6 \
	--major_version=2 \
	--max_timestamp=1649646814 \
	--dynamic_partition_info_file=/tmp/dynamic_partitions_info.zH7uRw
```

和以前传统的非动态分区命令相比，这里多了一个参数 `--dynamic_partition_info_file`，这个参数指向了一个从新 target 包中解压缩出来的动态分区配置文件。

`delta_generator` 工具读取 `--dynamic_partition_info_file` 参数指定文件的内容:

```bash
$ unzip -p dist_new/inuvik-target_files-eng.rg935739.zip META/dynamic_partitions_info.txt
super_partition_groups=bcm_ref
bcm_ref_size=1510998016
bcm_ref_partition_list=system vendor
```

解析并将其存放到 `payload_config.target.dynamic_partition_metadata` 结构中。

在准备输出到 payload 的准备阶段 `PayloadFile::Init()`，将解析的内容存储到 `manifest` 的 `dynamic_partition_metadata` 字段中，这个字段是 `DynamicPartitionMetadata`类型的数据。

随后，将整个 manifest 序列化输出到 payload.bin 中，伴随的还有对 manifest 数据的签名。



OTA 升级时，接收到数据以后，调用 `DeltaPerformer::Write` 对接收到的数据进行处理。

其中，接收到 payload 文件数据以后，解析 payload 头部的 metadata (这里是 payload 的 metadata，不同于动态分区的 metadata)，得到 payload 的 Manifest 数据，其中就包含使用 `delta_generator` 打包的动态分区 metadata 数据，存放在 Manifest 的 `dynamic_partition_metadata` 字段中。



## 5. 后续计划

整个动态分区对我个人来说，我最关心的有两个问题：

- 动态分区是什么？

- 动态分区在 OTA 升级时是如何处理的?

所以整个系列我最想写的还是第一篇和本篇，第一篇主要讲述动态分区是什么，是如何映射的？本篇主要讲述的是动态分区在 OTA 升级是如何更新的，至于动态分区在编译时如何配置，在系统初始化时时如何加载的，网上讲这方面的文章很多，不是我关注的重点。

但如果不写动态分区的编译配置，不写动态分区在启动时如何加载，显然整个系列是不完整的，所以后面还是会开一篇分析启动流程，看下动态分区如何加载。

另外，在写第一篇时，突然意识到除了原生动态分区之外，也应该单独写一篇如何升级改造动态分区的介绍。

因此，整个系列后续大概还有两篇，一篇提供一个升级改造动态分区的例子，一篇分析动态分区在启动时如何加载，这样整个动态分区详解系列就算完满了。

