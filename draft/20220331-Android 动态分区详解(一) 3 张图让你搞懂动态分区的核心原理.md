# Android 动态分区详解(一): 5 张图让你搞懂动态分区的核心原理

## 1. 动态分区详解的背景

### 1.1 背景

之前一直没有去了解动态分区，但随着最近重新研究 Android OTA 升级，发现动态分区是一个绕不过去的坎。

从 Android Q 引入动态分区，到 Android R/S 在动态分区之上增加虚拟分区管理, OTA 升级时需要对分区变更进行处理，不了解动态分区就无法深入 Android OTA 升级。

因此最近花了些时间阅读代码，学习 Android 动态分区。学习在 linux device mapper 机制之上，Android 系统对动态分区的各种操作处理。因此，这一系列没有包含 linux 底层 device mapper 驱动解读，后面看情况会考虑深入。

目前这几篇文章的大致规划如下，后续可能会有变动：

1. Android 动态分区详解(一): 3 张图让你搞懂动态分区的核心原理
2. Android 动态分区详解(二): 相关工具介绍
3. Android 动态分区详解(三): 动态分区配置和 super.img 的生成
4. Android 动态分区详解(四): 动态分区的加载
5. Android 动态分区详解(五): OTA 中对动态分区的处理

### 1.2 动态分区的本质

请原谅我总是忍不住想说一些空洞的废话。

动态分区管理的本质是什么？

分区数据是对磁盘上数据分布的描述，系统挂载磁盘时读取数据，在内存中建立相应数据结构，用于后续对磁盘进行管理。可见这里需要先提前生成分区数据，然后读取数据，一旦分区数据写入后就固定了。

动态分区，顾名思义就是分区是动态的，不是一成不变的，可以根据需要改变。动态分区管理的本质就是对分区数据的增删改查操作，操作的对象就是动态分区描述数据 metadata。

围绕 metadata 数据进行增删改查，就是 Android 动态分区管理的核心内容:

- 增: metadata 是如何生成的？
- 删: 没有删除 metadata 的需求，不需要删除操作
- 改: OTA 升级时是如何修改 metadata 的?
- 查: 系统如何读取(查询) metadata 数据并进行解析，并基于解析结果创建分区?

## 2. Linux device mapper 驱动

> 学习动态分区需要先学习 device mapper 驱动吗？
>
> 答: 不需要。知道一点 device mapper 的基本原理就好，看懂下面这张图就够了。
>
> 



## 3. Android 动态分区布局

### 3.1 动态分区布局

Android 从 Q 10 开始引入动态分区 `super`，将原来的 `system_a`, `system_b`, `vendor_a`, `vendor_b` 等打包到到这个分区中。下面是 Android 官方的分区转换布局图:

> 这个图全网随处可见，好吧，我承认我绕不开这张图了~

![分区表布局](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/dynamic_partitions_table.png)

> 来源: https://source.android.google.cn/devices/tech/ota/dynamic_partitions/implement

**图 2.** 转换为动态分区时的新物理分区表布局

既然新的 `super`分区内部包含了多个原来的分区，那要如何才能识别这些内部的分区呢？答案就是引入 `super` 分区的描述数据。

于是，在 `super` 分区一开始的地方存储用于描述分区布局的 `metadata`，系统加载时读取 `metadata`，对其进行解析，在内存中建立 `super` 分区布局描述的 `LpMetadata` 结构体，就知道内部的各个分区都位于哪个地方。

```c++
/* file: system/core/fs_mgr/liblp/include/liblp/liblp.h */
struct LpMetadata {
    LpMetadataGeometry geometry;
    LpMetadataHeader header;
    std::vector<LpMetadataPartition> partitions;
    std::vector<LpMetadataExtent> extents;
    std::vector<LpMetadataPartitionGroup> groups;
    std::vector<LpMetadataBlockDevice> block_devices;
};
```



换句话说，`metadata` 就是 `LpMetadata` 结构在磁盘分区上的物理存储数据，而 `LpMetadata`是其在内存中的数据结构。



### 3.2 metadata 数据布局

在开始研究内存数据结构之前，先从宏观上看下物理存储结构是怎样的。

下图是我基于 Android 官方的布局图 (**图 2.** 转换为动态分区时的新物理分区表布局)，对 `metadata` 部分细化后的的结构示意图。

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-Layout.png)

**图 3.** 安卓动态分区布局及其 metadata

上面这张图的重点：

- `super` 分区布局

  - 分区头部存放描述分区布局的 `metadata` 数据

  - `metadata`之后依次存放两组槽位(`slot`)的分区数据
  - 

## 4. Android 动态分区的核心数据结构

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-DataStructure.png)



## 5. Android 动态分区映射示例

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-MappingExample.png)











