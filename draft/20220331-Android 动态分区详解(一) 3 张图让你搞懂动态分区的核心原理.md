# Android 动态分区详解(一): 5 张图让你搞懂动态分区的原理

## 1. 动态分区详解的背景

### 1.1 背景

之前一直没有去了解动态分区，但随着最近重新研究 Android OTA 升级，发现动态分区是一个绕不过去的坎。

从 Android Q 引入动态分区，到 Android R/S 在动态分区之上增加虚拟分区管理, OTA 升级时需要对分区变更进行处理，不了解动态分区就无法深入 Android OTA 升级。

因此最近花了些时间阅读代码，学习 Android 动态分区。学习在 linux device mapper 机制之上，Android 系统对动态分区的各种操作处理。因此，这一系列没有包含 linux 底层 device mapper 驱动解读，后面看情况会考虑深入。

目前这几篇文章的大致规划如下，后续可能会有变动：

1. Android 动态分区详解(一): 5 张图让你搞懂动态分区的原理
2. Android 动态分区详解(二): 相关工具介绍
3. Android 动态分区详解(三): 动态分区配置和 super.img 的生成
4. Android 动态分区详解(四): 动态分区的加载
5. Android 动态分区详解(五): OTA 中对动态分区的处理

### 1.2 动态分区的本质

请原谅我总是忍不住想说一些空洞的废话。

动态分区管理的本质是什么？

分区数据是对磁盘上数据分布的描述，系统挂载磁盘时读取数据，在内存中建立相应数据结构，用于后续对磁盘进行管理。可见这里需要先提前生成分区数据，然后读取数据，一旦分区数据写入后就固定了。

动态分区，顾名思义就是分区是动态的，不是一成不变的，可以根据需要改变。动态分区管理的本质就是对分区数据的增删改查操作，操作的对象就是动态分区描述数据 metadata。

围绕 metadata 数据进行增删改查，就是 Android 动态分区管理的核心内容:

- 增: metadata 是如何生成的？
- 删: 没有删除 metadata 的需求，不需要删除操作
- 改: OTA 升级时是如何修改 metadata 的?
- 查: 系统如何读取(查询) metadata 数据并进行解析，并基于解析结果创建分区?

## 2. Linux device mapper 驱动

Android 动态分区最底层基于 Linux 的 device mapper 机制，将 `super` 分区的各个不同部分映射成 device mapper 的 linear 设备。因此，肯定有人会问，学习动态分区前需要先学习 device mapper 驱动吗？

答案是不需要，我就深入没有学习过 device mapper 驱动，但并不妨碍我对 Android 动态分区管理的理解。

> **注意:**
>
> 我强调的是对**Android 动态分区管理**的理解，而不是动态分区底层机制的理解，如果你想知道动态分区最底层实现的细节，还是应该去读一读 device mapper 驱动。
>
> Linux device mapper 相关驱动位于: 

当然，在理解动态分区管理之前，能知道一些 device mapper 的基本原理就更好，我这里所谓的基本原理，是你能看懂下面这张图:

![《(转载)device mapper原理》](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/dm_2.gif)

**图 1.** Device mapper 内核中各对象的层次关系

说下**图 1** 的重点:

- 虚拟设备 `Mapped Device` 基于驱动 `Target Driver`和内部的映射表 `Mapping Table` 来实现
- 一个虚拟设备 `Mapped Device` 可以由一个或多个 `Target Device` 映射组成，参与映射的 `Target Device` 本身也可能是虚拟设备

所以，一个设备可能是真实的，也可能是虚拟的。对虚拟设备的访问会被 `Target Driver` 拦截，然后通过 `Mapping Table` 转发给另外一个设备。例如，在 Android Q 上，对 `system_a`或 `vendor_a` 分区的访问被驱动拦截并转发为对 `super` 分区某个区域的访问。而这里的拦截以及转发对用户是透明的，用户根本不知道，也不需要知道他最终访问的到底是哪个设备。



如果不打算读 device mapper 驱动代码，但又希望在总体上对 device mapper 有比较全面的认识，推荐阅读[《(转载)device mapper原理》](https://blog4jimmy.com/2018/03/457.html)这篇文章。

> 这篇文章源自 IBM [《Linux 内核中的 Device Mapper 机制》: https://www.ibm.com/developerworks/cn/linux/l-devmapper/](https://www.ibm.com/developerworks/cn/linux/l-devmapper/)，但该文的原始内容已经不可访问。



## 3. Android 动态分区布局

### 3.1 动态分区布局

Android 从 Q 10 开始引入动态分区 `super`，将原来的 `system_a`, `system_b`, `vendor_a`, `vendor_b` 等打包到到这个分区中。下面是 Android 官方的分区转换布局图:

> 这个图全网随处可见，好吧，我承认我绕不开这张图了~

![分区表布局](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/dynamic_partitions_table.png)

> 来源: https://source.android.google.cn/devices/tech/ota/dynamic_partitions/implement

**图 2.** 转换为动态分区时的新物理分区表布局

既然新的 `super`分区内部包含了多个原来的分区，那要如何才能识别这些内部的分区呢？答案就是引入数据来描述 `super` 分区的布局。

于是，在 `super` 分区开头存储用于描述分区布局的 `metadata`，和磁盘开头存储用于描述磁盘分区布局的 `gpt` 数据的道理一样。系统加载动态分区时读取 `metadata`，对其进行解析，在内存中建立 `super` 分区布局描述的 `LpMetadata` 结构体，就知道内部的各个分区都位于哪个地方。

```c++
/* file: system/core/fs_mgr/liblp/include/liblp/liblp.h */
struct LpMetadata {
    LpMetadataGeometry geometry;
    LpMetadataHeader header;
    std::vector<LpMetadataPartition> partitions;
    std::vector<LpMetadataExtent> extents;
    std::vector<LpMetadataPartitionGroup> groups;
    std::vector<LpMetadataBlockDevice> block_devices;
};
```



换句话说，`metadata` 就是 `LpMetadata` 结构在 `super` 分区上的物理存储数据，而 `LpMetadata`是 `metadata` 在内存中的数据结构。`LpMetadata `中的信息会被转换成**图 1** 中的映射表`Mappting Table`， 基于这个映射表，`super` 分区对应设备`/dev/block/by-name/super` 的不同部分被映射成多个虚拟设备，如`/dev/block/mapper/system_a`, `/dev/block/mapper/vendor_a` 等。



### 3.2 metadata 数据布局

在开始研究内存数据结构 `LpMetadata` 之前，先从宏观上看下物理存储的 `metadata` 是怎样的。

下图是我基于 Android 官方的布局图 (**图 2.** 转换为动态分区时的新物理分区表布局)，对 `metadata` 部分细化后的的结构示意图。

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-Layout.png)

**图 3.** 安卓动态分区布局及其 metadata

对 metadata，可以分层 3 个层次，见**图 2** 最右侧的 3 列：

第 1 层，super 分区(宏观)

- `super` 分区头部存放描述分区内部布局的 `metadata` 数据
- `metadata`数据之后依次存放两组槽位(`slot`)的分区数据

第 2 层，metadata 数据(中观)

- `metadata` 数据开始前预留了 4K 的空间，所以 metadata 数据从 4K 的偏移位置开始

- metadata 数据由 Geometry 和 Metadata 两部分组成

  - Geometry 大小为 4K，数据除自身外，还有个一个备份，紧挨着 Geometry 存放
  - Metadata 大小 64K，按槽位(slot)存放，每个槽位有一份 Metadata 数据，所有槽位的 Metadata 数据结束后开始存放其备份数据
  - 分区加载时，根据分区对应槽位，读取相应槽位的 Metadata 和其备份数据

  > **为什么槽位有两个，但是这里的 Metadata 有 3 份呢？**
  >
  > 我一开始也有这个疑惑，经过核对传递给 lpmake 的参数后发现确实是 3 份。
  >
  > 在 Android 编译生成 super.img 时，传递给 metadata 生成工具 lpmake 的参数 "`--metadata-slots 3`"，所以  Metadata 有 3 份。lpmake 工具只不过是一个干活的苦逼，上层的编译系统下指令说生成几份 Metadata 就生成几份。
  >
  > 至于为什么要传递 "`--metadata-slots 3`" 而不是 "`--metadata-slots 2`" 给 lpmake ？那就是 `builder_super_image.py` 脚本的事情了，相关代码如下:
  >
  > ```python
  > 
  > ```
  >
  > 为什么要这么写，去问谷大爷吧~知道原因的大神，也请在评论区不吝赐教~

- 第 3 层，Geometry 和 Metadata(微观)

  - Geometry 内部是大小为 58 字节的 LpMetadataGeometry 结构数据，填充到 4K 大小
  - Metadata 内部包含 LpMetadataHeader, LpMetadataPartition, LpMetadataExtent, LpMetadataPartitionGroup, LpMetadataBlockDevice 等数据结构，填充到 64K 大小

  至于 Geometry 和 Metadata 内部每个数据结构的具体字段，阅读具体代码时再深入。

## 4. Android 动态分区的核心数据结构

说完 Android 动态分区的描述数据，自然会

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-DataStructure.png)



## 5. Android 动态分区映射示例

![](images-20220331-Android 动态分区详解(一) 3 张图让你搞懂动态分区的核心原理/DynamicPartitionMetadata-MappingExample.png)











